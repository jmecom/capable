package safe
module sys::string

use sys::buffer
use sys::bytes
use sys::vec

pub struct SplitOnce {
  left: string,
  right: string
}

impl string {
  /// Intrinsic; implemented by the runtime.
  pub fn len(self) -> i32 {
    return 0
  }

  /// Intrinsic; implemented by the runtime.
  pub fn byte_at(self, index: i32) -> u8 {
    return 0u8
  }

  /// Intrinsic; implemented by the runtime.
  pub fn as_slice(self) -> Slice<u8> {
    return ()
  }

  /// bytes() is an alias for as_slice().
  pub fn bytes(self) -> Slice<u8> {
    return self.as_slice()
  }

  /// Intrinsic; implemented by the runtime.
  pub fn split_whitespace(self) -> Vec<string> {
    return ()
  }

  /// Intrinsic; implemented by the runtime.
  pub fn lines(self) -> Vec<string> {
    return ()
  }

  /// Intrinsic; implemented by the runtime.
  pub fn split(self, delim: u8) -> Vec<string> {
    return ()
  }

  /// Intrinsic; implemented by the runtime.
  pub fn split_once(self, delim: u8) -> Result<SplitOnce, unit> {
    return Err(())
  }

  /// Intrinsic; implemented by the runtime.
  pub fn trim(self) -> string {
    return ""
  }

  /// Intrinsic; implemented by the runtime.
  pub fn trim_start(self) -> string {
    return ""
  }

  /// Intrinsic; implemented by the runtime.
  pub fn trim_end(self) -> string {
    return ""
  }

  /// Intrinsic; implemented by the runtime.
  pub fn trim_prefix(self, prefix: string) -> string {
    return ""
  }

  /// Intrinsic; implemented by the runtime.
  pub fn trim_suffix(self, suffix: string) -> string {
    return ""
  }

  /// split_lines() is an alias for lines().
  pub fn split_lines(self) -> Vec<string> {
    return self.lines()
  }

  pub fn starts_with(self, prefix: string) -> bool {
    let self_len = self.len()
    let prefix_len = prefix.len()
    if (prefix_len > self_len) {
      return false
    }
    let i = 0
    while (i < prefix_len) {
      if self.byte_at(i) != prefix.byte_at(i) {
        return false
      }
      i = i + 1
    }
    return true
  }

  pub fn ends_with(self, suffix: string) -> bool {
    let self_len = self.len()
    let suffix_len = suffix.len()
    if (suffix_len > self_len) {
      return false
    }
    let i = 0
    while (i < suffix_len) {
      let idx = self_len - suffix_len + i
      if self.byte_at(idx) != suffix.byte_at(i) {
        return false
      }
      i = i + 1
    }
    return true
  }

  pub fn starts_with_byte(self, prefix: u8) -> bool {
    if (self.len() == 0) {
      return false
    }
    return self.byte_at(0) == prefix
  }

  pub fn ends_with_byte(self, suffix: u8) -> bool {
    let len = self.len()
    if (len == 0) {
      return false
    }
    return self.byte_at(len - 1) == suffix
  }

  pub fn eq(self, other: string) -> bool {
    let self_len = self.len()
    let other_len = other.len()
    if (self_len != other_len) {
      return false
    }
    let i = 0
    while (i < self_len) {
      if self.byte_at(i) != other.byte_at(i) {
        return false
      }
      i = i + 1
    }
    return true
  }

  pub fn is_empty(self) -> bool {
    return self.len() == 0
  }

  pub fn byte_at_checked(self, index: i32) -> Result<u8, unit> {
    if (index < 0) {
      return Err(())
    }
    if (index >= self.len()) {
      return Err(())
    }
    return Ok(self.byte_at(index))
  }

  pub fn index_of_byte(self, needle: u8) -> Result<i32, unit> {
    let len = self.len()
    let i = 0
    while (i < len) {
      if (self.byte_at(i) == needle) {
        return Ok(i)
      }
      i = i + 1
    }
    return Err(())
  }

  pub fn last_index_of_byte(self, needle: u8) -> Result<i32, unit> {
    let len = self.len()
    if (len == 0) {
      return Err(())
    }
    let i = len - 1
    while (true) {
      if (self.byte_at(i) == needle) {
        return Ok(i)
      }
      if (i == 0) {
        break
      }
      i = i - 1
    }
    return Err(())
  }

  pub fn contains_byte(self, needle: u8) -> bool {
    match (self.index_of_byte(needle)) {
      Ok(_) => { return true }
      Err(_) => { return false }
    }
  }

  pub fn count_byte(self, needle: u8) -> i32 {
    let len = self.len()
    let i = 0
    let count = 0
    while (i < len) {
      if (self.byte_at(i) == needle) {
        count = count + 1
      }
      i = i + 1
    }
    return count
  }

  pub fn is_ascii(self) -> bool {
    let len = self.len()
    let i = 0
    while (i < len) {
      if (self.byte_at(i) > '\x7f') {
        return false
      }
      i = i + 1
    }
    return true
  }
}
