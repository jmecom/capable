/// Vec helpers for built-in element types.
/// Vec<T> is an owned, heap-backed growable container (not a view).
/// Use Slice/MutSlice for non-owning views into byte data.
package safe
module sys::vec

use sys::buffer

/// Generic Vec marker type (owned, heap-backed container).
pub copy opaque struct Vec<T>

/// Vec errors.
pub enum VecErr {
  /// Index is out of range.
  OutOfRange,
  /// Vec is empty.
  Empty
}

impl<T> Vec<T> {
  /// Length in elements.
  pub fn len(self) -> i32 {
    return 0
  }

  /// True if empty.
  pub fn is_empty(self) -> bool {
    return self.len() == 0
  }

  /// Get element at index.
  pub fn get(self, i: i32) -> Result<T, VecErr> {
    return Err(VecErr::OutOfRange)
  }

  /// Get the first element.
  pub fn first(self) -> Result<T, VecErr> {
    return self.get(0)
  }

  /// Get the last element.
  pub fn last(self) -> Result<T, VecErr> {
    let len = self.len()
    if (len == 0) {
      return Err(VecErr::Empty)
    }
    return self.get(len - 1)
  }

  /// Set element at index.
  pub fn set(self, i: i32, x: T) -> Result<unit, VecErr> {
    return Err(VecErr::OutOfRange)
  }

  /// Append one element.
  pub fn push(self, x: T) -> Result<unit, buffer::AllocErr> {
    return Err(buffer::AllocErr::Oom)
  }

  /// Append another Vec.
  pub fn extend(self, other: Vec<T>) -> Result<unit, buffer::AllocErr> {
    return Err(buffer::AllocErr::Oom)
  }

  /// Append another Vec (alias).
  pub fn push_all(self, other: Vec<T>) -> Result<unit, buffer::AllocErr> {
    return self.extend(other)
  }

  /// Pop last element.
  pub fn pop(self) -> Result<T, VecErr> {
    return Err(VecErr::Empty)
  }

  /// Remove all elements.
  pub fn clear(self) -> unit {
    while (true) {
      match (self.pop()) {
        Ok(_) => { }
        Err(_) => { break }
      }
    }
    return ()
  }

  /// True if the Vec contains value.
  pub fn contains(self, value: T) -> bool {
    let len = self.len()
    let i = 0
    while (i < len) {
      match (self.get(i)) {
        Ok(v) => {
          if (v == value) {
            return true
          }
        }
        Err(_) => { return false }
      }
      i = i + 1
    }
    return false
  }

  /// Count occurrences of value.
  pub fn count(self, value: T) -> i32 {
    let len = self.len()
    let i = 0
    let out = 0
    while (i < len) {
      match (self.get(i)) {
        Ok(v) => {
          if (v == value) {
            out = out + 1
          }
        }
        Err(_) => { return out }
      }
      i = i + 1
    }
    return out
  }

  /// Find the first index of value.
  pub fn index_of(self, value: T) -> Result<i32, VecErr> {
    let len = self.len()
    let i = 0
    while (i < len) {
      match (self.get(i)) {
        Ok(v) => {
          if (v == value) {
            return Ok(i)
          }
        }
        Err(_) => { return Err(VecErr::OutOfRange) }
      }
      i = i + 1
    }
    return Err(VecErr::OutOfRange)
  }

  /// Find the last index of value.
  pub fn last_index_of(self, value: T) -> Result<i32, VecErr> {
    let len = self.len()
    let i = len - 1
    while (i >= 0) {
      match (self.get(i)) {
        Ok(v) => {
          if (v == value) {
            return Ok(i)
          }
        }
        Err(_) => { return Err(VecErr::OutOfRange) }
      }
      i = i - 1
    }
    return Err(VecErr::OutOfRange)
  }

  /// Filter elements equal to value (numeric vecs only).
  pub fn filter(self, value: T) -> Vec<T> {
    return ()
  }

  /// Add delta to each element (numeric vecs only).
  pub fn map_add(self, delta: T) -> Vec<T> {
    return ()
  }
}

impl Vec<u8> {
  /// Append a slice of bytes.
  pub fn extend_slice(self, data: Slice<u8>) -> Result<unit, buffer::AllocErr> {
    let len = data.len()
    let i = 0
    while (i < len) {
      self.push(data.at(i))?
      i = i + 1
    }
    return Ok(())
  }

  /// Create a slice view of a range.
  pub fn slice(self, start: i32, len: i32) -> Result<Slice<u8>, VecErr> {
    return Err(VecErr::OutOfRange)
  }

  /// Borrow as a slice.
  pub fn as_slice(self) -> Slice<u8> {
    return ()
  }
}

impl Vec<string> {
  /// Join elements with a separator.
  pub fn join(self, sep: string) -> Result<string, buffer::AllocErr> {
    let len = self.len()
    let buf = buffer::new(0)?
    let i = 0
    while (i < len) {
      let part = match (self.get(i)) {
        Ok(v) => { v }
        Err(_) => { panic() }
      }
      if (i > 0) {
        buf.push_str(sep)?
      }
      buf.push_str(part)?
      i = i + 1
    }
    return buf.to_string()
  }
}
