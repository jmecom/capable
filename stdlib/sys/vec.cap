package safe
module sys::vec

use sys::buffer

pub copy capability struct VecU8
pub copy capability struct VecI32
pub copy capability struct VecString

pub enum VecErr {
  OutOfRange,
  Empty
}

impl VecU8 {
  pub fn len(self) -> i32 {
    return 0
  }

  pub fn get(self, i: i32) -> Result[u8, VecErr] {
    return Err(VecErr::OutOfRange)
  }

  pub fn set(self, i: i32, x: u8) -> Result[unit, VecErr] {
    return Err(VecErr::OutOfRange)
  }

  pub fn push(self, x: u8) -> Result[unit, buffer::AllocErr] {
    return Err(buffer::AllocErr::Oom)
  }

  pub fn pop(self) -> Result[u8, VecErr] {
    return Err(VecErr::Empty)
  }

  pub fn as_slice(self) -> Slice[u8] {
    return ()
  }
}

impl VecI32 {
  pub fn len(self) -> i32 {
    return 0
  }

  pub fn get(self, i: i32) -> Result[i32, VecErr] {
    return Err(VecErr::OutOfRange)
  }

  pub fn set(self, i: i32, x: i32) -> Result[unit, VecErr] {
    return Err(VecErr::OutOfRange)
  }

  pub fn push(self, x: i32) -> Result[unit, buffer::AllocErr] {
    return Err(buffer::AllocErr::Oom)
  }

  pub fn pop(self) -> Result[i32, VecErr] {
    return Err(VecErr::Empty)
  }
}

impl VecString {
  pub fn len(self) -> i32 {
    return 0
  }

  pub fn get(self, i: i32) -> Result[string, VecErr] {
    return Err(VecErr::OutOfRange)
  }

  pub fn push(self, x: string) -> Result[unit, buffer::AllocErr] {
    return Err(buffer::AllocErr::Oom)
  }

  pub fn pop(self) -> Result[string, VecErr] {
    return Err(VecErr::Empty)
  }
}
