/// Slice and allocation utilities.
/// Slice/MutSlice are lightweight, non-owning views into existing bytes.
package safe
module sys::buffer
use sys::vec
use sys::string
use sys::unsafe_ptr

/// Alloc capability for heap operations (heap-backed allocations).
pub copy opaque struct Alloc
/// Immutable slice view (non-owning).
pub copy struct Slice<T> {
  ptr: *T,
  len: i32
}
/// Mutable slice view (non-owning).
pub copy struct MutSlice<T> {
  ptr: *T,
  len: i32
}

/// Allocation errors.
pub enum AllocErr {
  /// Out of memory.
  Oom
}

/// Slice errors.
pub enum SliceErr {
  /// Index is out of range.
  OutOfRange
}

/// Copy a slice into a new owned slice using the provided allocator.
pub fn copy_slice(alloc: Alloc, data: Slice<u8>) -> Result<Slice<u8>, AllocErr> {
  let len = data.len()
  let raw = alloc.malloc(len)
  if (len > 0 && unsafe_ptr::ptr_is_null<u8>(raw)) {
    return Err(AllocErr::Oom)
  }
  let i = 0
  while (i < len) {
    let value = data.at(i)
    unsafe_ptr::ptr_write<u8>(unsafe_ptr::ptr_add<u8>(raw, i), value)
    i = i + 1
  }
  return Ok(alloc.slice_from_ptr(raw, len))
}

impl Alloc {
  /// Allocate raw bytes.
  pub fn malloc(self, size: i32) -> *u8 {
    return ()
  }

  /// Free raw bytes.
  pub fn free(self, ptr: *u8) -> unit {
    return ()
  }

  /// Reinterpret a *u8 as *u32.
  pub fn cast_u8_to_u32(self, ptr: *u8) -> *u32 {
    return ()
  }

  /// Reinterpret a *u32 as *u8.
  pub fn cast_u32_to_u8(self, ptr: *u32) -> *u8 {
    return ()
  }

  /// Create an immutable slice from a raw pointer.
  pub fn slice_from_ptr(self, ptr: *u8, len: i32) -> Slice<u8> {
    return Slice<u8> { ptr: ptr, len: len }
  }

  /// Create a mutable slice from a raw pointer.
  pub fn mut_slice_from_ptr(self, ptr: *u8, len: i32) -> MutSlice<u8> {
    return MutSlice<u8> { ptr: ptr, len: len }
  }

  /// Create a Vec<u8> with this Alloc (heap-backed).
  pub fn vec_u8_new(self) -> vec::Vec<u8> {
    return vec::new_with<u8>(self)
  }

  /// Create a Vec<u8> with capacity using this Alloc.
  pub fn vec_u8_with_capacity(self, capacity: i32) -> Result<vec::Vec<u8>, AllocErr> {
    return vec::with_capacity<u8>(self, capacity)
  }

  /// Free a Vec<u8> created with this Alloc.
  pub fn vec_u8_free(self, v: vec::Vec<u8>) -> unit {
    v.free()
    return ()
  }

  /// Create a Vec<i32> with this Alloc (heap-backed).
  pub fn vec_i32_new(self) -> vec::Vec<i32> {
    return vec::new_with<i32>(self)
  }

  /// Create a Vec<i32> with capacity using this Alloc.
  pub fn vec_i32_with_capacity(self, capacity: i32) -> Result<vec::Vec<i32>, AllocErr> {
    return vec::with_capacity<i32>(self, capacity)
  }

  /// Free a Vec<i32> created with this Alloc.
  pub fn vec_i32_free(self, v: vec::Vec<i32>) -> unit {
    v.free()
    return ()
  }

  /// Create a Vec<string> with this Alloc (heap-backed).
  pub fn vec_string_new(self) -> vec::Vec<string> {
    return vec::new_with<string>(self)
  }

  /// Create a Vec<string> with capacity using this Alloc.
  pub fn vec_string_with_capacity(self, capacity: i32) -> Result<vec::Vec<string>, AllocErr> {
    return vec::with_capacity<string>(self, capacity)
  }

  /// Free a Vec<string> created with this Alloc.
  pub fn vec_string_free(self, v: vec::Vec<string>) -> unit {
    v.free()
    return ()
  }
}

impl Slice<u8> {
  /// Length in bytes.
  pub fn len(self) -> i32 {
    return self.len
  }

  /// Index into the slice.
  pub fn at(self, i: i32) -> u8 {
    if (i < 0 || i >= self.len) {
      return 0u8
    }
    let ptr = unsafe_ptr::ptr_add<u8>(self.ptr, i)
    return unsafe_ptr::ptr_read<u8>(ptr)
  }

  /// Create a subslice view.
  pub fn slice(self, start: i32, len: i32) -> Result<Slice<u8>, SliceErr> {
    if (start < 0 || len < 0) {
      return Err(SliceErr::OutOfRange)
    }
    if (start > self.len) {
      return Err(SliceErr::OutOfRange)
    }
    if (start + len > self.len) {
      return Err(SliceErr::OutOfRange)
    }
    let ptr = unsafe_ptr::ptr_add<u8>(self.ptr, start)
    return Ok(Slice<u8> { ptr: ptr, len: len })
  }
}

impl MutSlice<u8> {
  /// Index into the mutable slice.
  pub fn at(self, i: i32) -> u8 {
    if (i < 0 || i >= self.len) {
      return 0u8
    }
    let ptr = unsafe_ptr::ptr_add<u8>(self.ptr, i)
    return unsafe_ptr::ptr_read<u8>(ptr)
  }

  /// Create a mutable subslice view.
  pub fn slice(self, start: i32, len: i32) -> Result<MutSlice<u8>, SliceErr> {
    if (start < 0 || len < 0) {
      return Err(SliceErr::OutOfRange)
    }
    if (start > self.len) {
      return Err(SliceErr::OutOfRange)
    }
    if (start + len > self.len) {
      return Err(SliceErr::OutOfRange)
    }
    let ptr = unsafe_ptr::ptr_add<u8>(self.ptr, start)
    return Ok(MutSlice<u8> { ptr: ptr, len: len })
  }
}
