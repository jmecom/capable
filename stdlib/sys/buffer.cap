package safe
module sys::buffer
use sys::vec

pub copy opaque struct Alloc
pub copy opaque struct Buffer
pub copy opaque struct Slice
pub copy opaque struct MutSlice

pub enum AllocErr {
  Oom
}

impl Alloc {
  pub fn malloc(self, size: i32) -> *u8 {
    return ()
  }

  pub fn free(self, ptr: *u8) -> unit {
    return ()
  }

  pub fn cast_u8_to_u32(self, ptr: *u8) -> *u32 {
    return ()
  }

  pub fn cast_u32_to_u8(self, ptr: *u32) -> *u8 {
    return ()
  }

  pub fn slice_from_ptr(self, ptr: *u8, len: i32) -> Slice[u8] {
    return ()
  }

  pub fn mut_slice_from_ptr(self, ptr: *u8, len: i32) -> MutSlice[u8] {
    return ()
  }

  pub fn buffer_new(self, initial_len: i32) -> Result[Buffer, AllocErr] {
    return Err(AllocErr::Oom)
  }

  pub fn buffer_free(self, b: Buffer) -> unit {
    return ()
  }

  pub fn vec_u8_new(self) -> vec::VecU8 {
    return ()
  }

  pub fn vec_u8_free(self, v: vec::VecU8) -> unit {
    return ()
  }

  pub fn vec_i32_new(self) -> vec::VecI32 {
    return ()
  }

  pub fn vec_i32_free(self, v: vec::VecI32) -> unit {
    return ()
  }

  pub fn vec_string_new(self) -> vec::VecString {
    return ()
  }

  pub fn vec_string_free(self, v: vec::VecString) -> unit {
    return ()
  }
}

impl Buffer {
  pub fn len(self) -> i32 {
    return 0
  }

  pub fn push(self, x: u8) -> Result[unit, AllocErr] {
    return Err(AllocErr::Oom)
  }

  pub fn extend(self, data: Slice[u8]) -> Result[unit, AllocErr] {
    return Err(AllocErr::Oom)
  }

  pub fn is_empty(self) -> bool {
    return false
  }

  pub fn as_slice(self) -> Slice[u8] {
    return ()
  }

  pub fn as_mut_slice(self) -> MutSlice[u8] {
    return ()
  }
}

impl Slice[u8] {
  pub fn len(self) -> i32 {
    return 0
  }

  pub fn at(self, i: i32) -> u8 {
    return 0
  }
}

impl MutSlice[u8] {
  pub fn at(self, i: i32) -> u8 {
    return 0
  }
}
