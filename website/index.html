<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Capable</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --ink: #baccd4;
      --muted: #77758a;
      --surface: #10121c;
      --panel: #1a1c28;
      --edge: #252834;
      --accent: #f57c6c;
      --accent-hover: #ff9a8f;
      --mono: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }

    body {
      font-family: var(--mono);
      color: var(--ink);
      background: var(--surface);
      line-height: 1.6;
      font-size: 15px;
    }

    #dot-grid {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 0;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 2rem;
      padding: 0 1.5rem;
      height: 52px;
      border-bottom: 1px solid rgba(186, 204, 212, 0.1);
      background: rgba(16, 18, 28, 0.95);
      backdrop-filter: blur(10px);
    }

    .logo {
      font-weight: 700;
      font-size: 1rem;
      letter-spacing: 0.05em;
      color: var(--ink);
    }

    nav {
      display: flex;
      gap: 0.25rem;
    }

    .tab {
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      color: var(--muted);
      font-family: var(--mono);
      font-size: 0.85rem;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.15s;
    }

    .tab:hover {
      color: var(--ink);
      background: rgba(186, 204, 212, 0.05);
    }

    .tab.active {
      color: var(--accent);
      background: rgba(245, 124, 108, 0.1);
    }

    .header-right {
      margin-left: auto;
    }

    .header-right a {
      color: var(--muted);
      text-decoration: none;
      font-size: 0.85rem;
    }

    .header-right a:hover {
      color: var(--ink);
    }

    main {
      position: relative;
      z-index: 1;
      min-height: calc(100vh - 52px);
    }

    .page {
      display: none;
      padding: 2rem;
      max-width: 900px;
      margin: 0 auto;
    }

    .page.active {
      display: block;
    }

    /* Home page */
    .hero {
      margin-bottom: 3rem;
    }

    .hero h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .hero .tagline {
      color: var(--muted);
      font-size: 1.1rem;
      margin-bottom: 1.5rem;
    }

    .hero-code {
      margin-bottom: 3rem;
    }

    .security-section {
      margin-bottom: 3rem;
    }

    .security-section h2 {
      font-size: 1.4rem;
      margin-bottom: 1rem;
      color: var(--accent);
    }

    .security-section > p {
      font-size: 1rem;
      margin-bottom: 1.5rem;
      line-height: 1.7;
    }

    .security-comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    @media (max-width: 700px) {
      .security-comparison {
        grid-template-columns: 1fr;
      }
    }

    .comparison-block {
      padding: 1.25rem;
      border-radius: 6px;
      border: 1px solid var(--edge);
    }

    .comparison-block.problem {
      background: rgba(255, 100, 100, 0.05);
      border-color: rgba(255, 100, 100, 0.2);
    }

    .comparison-block.solution {
      background: rgba(100, 255, 150, 0.05);
      border-color: rgba(100, 255, 150, 0.2);
    }

    .comparison-block h4 {
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .comparison-block.problem h4 {
      color: #ff8a80;
    }

    .comparison-block.solution h4 {
      color: #69f0ae;
    }

    .comparison-block p {
      font-size: 0.9rem;
      color: var(--ink);
      line-height: 1.6;
    }

    .enforcement {
      background: var(--panel);
      border: 1px solid var(--edge);
      border-radius: 6px;
      padding: 1.5rem;
    }

    .enforcement h3 {
      font-size: 1rem;
      margin-bottom: 1rem;
      color: var(--ink);
    }

    .enforcement-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
    }

    @media (max-width: 700px) {
      .enforcement-grid {
        grid-template-columns: 1fr;
      }
    }

    .enforcement-item strong {
      display: block;
      color: var(--accent);
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .enforcement-item p {
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.6;
    }

    .features {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 3rem;
    }

    @media (max-width: 700px) {
      .features {
        grid-template-columns: 1fr;
      }
    }

    .feature {
      padding: 1.25rem;
      background: var(--panel);
      border: 1px solid var(--edge);
      border-radius: 6px;
    }

    .feature h3 {
      color: var(--accent);
      font-size: 0.95rem;
      margin-bottom: 0.5rem;
    }

    .feature p {
      color: var(--muted);
      font-size: 0.9rem;
    }

    /* Code blocks */
    pre, .code-block {
      background: #0e0f18;
      border: 1px solid var(--edge);
      border-radius: 6px;
      padding: 1rem;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
    }

    code {
      font-family: var(--mono);
    }

    /* Syntax highlighting */
    .hl-keyword { color: #c792ea; }
    .hl-type { color: #82aaff; }
    .hl-string { color: #c3e88d; }
    .hl-number { color: #f78c6c; }
    .hl-comment { color: #546e7a; font-style: italic; }

    /* Tutorial page */
    #tutorial-content {
      line-height: 1.7;
    }

    #tutorial-content h1 {
      font-size: 2rem;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--edge);
    }

    #tutorial-content h2 {
      font-size: 1.4rem;
      margin-top: 2.5rem;
      margin-bottom: 1rem;
      color: var(--accent);
    }

    #tutorial-content h3 {
      font-size: 1.1rem;
      margin-top: 2rem;
      margin-bottom: 0.75rem;
    }

    #tutorial-content p {
      margin-bottom: 1rem;
    }

    #tutorial-content ul {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
    }

    #tutorial-content li {
      margin-bottom: 0.25rem;
    }

    #tutorial-content code {
      background: rgba(245, 124, 108, 0.1);
      padding: 0.15em 0.4em;
      border-radius: 3px;
      font-size: 0.9em;
    }

    #tutorial-content pre code {
      background: transparent;
      padding: 0;
    }

    #tutorial-content .code-block {
      margin-bottom: 1.5rem;
    }

    #tutorial-content hr {
      border: none;
      border-top: 1px solid var(--edge);
      margin: 2rem 0;
    }

    #tutorial-content a {
      color: var(--accent);
    }

    /* Stdlib page */
    .stdlib-layout {
      display: grid;
      grid-template-columns: 250px 1fr;
      gap: 2rem;
      max-width: 1200px;
    }

    .stdlib-nav {
      position: sticky;
      top: 70px;
      max-height: calc(100vh - 90px);
      overflow-y: auto;
      padding: 1rem;
      background: var(--panel);
      border: 1px solid var(--edge);
      border-radius: 6px;
    }

    .stdlib-nav h3 {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--muted);
      margin-bottom: 0.75rem;
    }

    .module-link {
      display: block;
      padding: 0.4rem 0.6rem;
      color: var(--ink);
      text-decoration: none;
      border-radius: 4px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .module-link:hover {
      background: rgba(186, 204, 212, 0.05);
    }

    .module-link.active {
      background: rgba(245, 124, 108, 0.1);
      color: var(--accent);
    }

    .stdlib-content {
      min-width: 0;
    }

    .module-header {
      margin-bottom: 1.5rem;
    }

    .module-header h2 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }

    .module-path {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .module-docs {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: var(--panel);
      border-radius: 6px;
    }

    .item-section h3 {
      font-size: 1rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin: 2rem 0 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--edge);
    }

    .item {
      padding: 0.75rem 0;
      border-bottom: 1px solid rgba(186, 204, 212, 0.05);
    }

    .item:last-child {
      border-bottom: none;
    }

    .item-sig {
      color: var(--accent);
      font-weight: 500;
      font-size: 0.95rem;
    }

    .item-impl {
      color: var(--muted);
      font-size: 0.85rem;
      margin-top: 0.25rem;
    }

    .item-docs {
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }

    .source-toggle {
      display: inline-block;
      margin-top: 1.5rem;
      padding: 0.5rem 1rem;
      background: var(--panel);
      border: 1px solid var(--edge);
      border-radius: 4px;
      color: var(--accent);
      font-family: var(--mono);
      font-size: 0.85rem;
      cursor: pointer;
    }

    .source-toggle:hover {
      background: rgba(245, 124, 108, 0.1);
    }

    .source-code {
      margin-top: 1rem;
    }

    @media (max-width: 800px) {
      .stdlib-layout {
        grid-template-columns: 1fr;
      }
      .stdlib-nav {
        position: static;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <canvas id="dot-grid"></canvas>

  <header>
    <div class="logo">Capable</div>
    <nav>
      <button class="tab active" data-page="home">Home</button>
      <button class="tab" data-page="tutorial">Tutorial</button>
      <button class="tab" data-page="stdlib">Stdlib</button>
    </nav>
    <div class="header-right">
      <a href="https://github.com/jmecom/capable" target="_blank">GitHub</a>
    </div>
  </header>

  <main>
    <!-- Home Page -->
    <div id="home" class="page active">
      <div class="hero">
        <h1>Capable</h1>
        <p class="tagline">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>
      </div>

      <pre class="hero-code"><code><span class="hl-keyword">module</span> config_reader
<span class="hl-keyword">use</span> sys::system
<span class="hl-keyword">use</span> sys::fs

<span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> main(rc: <span class="hl-type">RootCap</span>) -&gt; <span class="hl-type">i32</span> {
  <span class="hl-comment">// Mint a filesystem capability scoped to ./config</span>
  <span class="hl-keyword">let</span> fs = rc.mint_filesystem(&quot;./config&quot;)
  <span class="hl-keyword">let</span> dir = fs.root_dir()
  <span class="hl-keyword">let</span> file = dir.open_read(&quot;app.txt&quot;)

  <span class="hl-keyword">match</span> file.read_to_string() {
    <span class="hl-type">Ok</span>(contents) =&gt; {
      rc.mint_console().println(contents)
      <span class="hl-keyword">return</span> <span class="hl-number">0</span>
    }
    <span class="hl-type">Err</span>(e) =&gt; { <span class="hl-keyword">return</span> <span class="hl-number">1</span> }
  }
}</code></pre>

      <div class="security-section">
        <h2>Capability-Based Security</h2>
        <p>Capable is a systems language where <strong>authority is a value</strong>. Code cannot perform privileged operations&mdash;filesystem access, networking, console output&mdash;without explicitly receiving a capability token.</p>

        <div class="security-comparison">
          <div class="comparison-block problem">
            <h4>The Problem</h4>
            <p>In typical systems languages, the OS is ambiently available. Any code in your process can call <code>open()</code>, <code>connect()</code>, or <code>exec()</code>. When you pull in a dependency, you're trusting it&mdash;and all of its transitive dependencies&mdash;not to be malicious or compromised.</p>
          </div>
          <div class="comparison-block solution">
            <h4>The Solution</h4>
            <p>In Capable, safe code can only perform OS actions by calling <code>sys.*</code> functions, and those require capability arguments. A library cannot read your disk unless you pass it a <code>ReadFS</code>. It cannot phone home unless you pass it a <code>Net</code>. Authority flow is explicit and reviewable.</p>
          </div>
        </div>

        <div class="enforcement">
          <h3>Two-Layer Enforcement</h3>
          <div class="enforcement-grid">
            <div class="enforcement-item">
              <strong>Static (Compiler)</strong>
              <p>No capability value in scope? The code won't compile. Privileged functions only exist in <code>sys.*</code> and require capability arguments. Capability types are opaque&mdash;user code cannot forge them.</p>
            </div>
            <div class="enforcement-item">
              <strong>Dynamic (Runtime)</strong>
              <p>Capabilities encode attenuation. A <code>ReadFS("./config")</code> cannot escape its root directory. The runtime validates paths, normalizes traversals, and enforces scoped rights.</p>
            </div>
          </div>
        </div>
      </div>

      <div class="features">
        <div class="feature">
          <h3>Linear and Affine Types</h3>
          <p>Move-only types prevent use-after-move. Linear capabilities must be consumed on all code paths. Attenuation methods consume the original capability&mdash;you can't keep both the powerful and attenuated versions.</p>
        </div>
        <div class="feature">
          <h3>Systems Programming</h3>
          <p>No garbage collector. Explicit memory management. Compiles to native code via Cranelift. Safe code is memory-safe; unsafe code is clearly marked with <code>package unsafe</code>.</p>
        </div>
      </div>
    </div>

    <!-- Tutorial Page -->
    <div id="tutorial" class="page">
      <div id="tutorial-content">
        <h1>Capable Tutorial</h1>
<p>Capable is a small, capability-secure systems language. Authority is a value: if</p>
<p>you did not receive a capability, you cannot perform that action. This is in contrast</p>
<p>to most languages. Normally, any piece of code in your program, whether that be from</p>
<p>a third-party library or yourself, has full permissions. In Capable, code only</p>
<p>get the capabilities you pass it, so authority is explicit, auditable, and narrow</p>
<p>by default.</p>
<p>This tutorial is a cohesive walk-through of the language as it exists today.</p>
<p>It focuses on how to write real programs, how the capability model works, and</p>
<p>how memory is managed.</p>
<h2>1) Hello, console</h2>
<pre class="code-block"><code><span class="hl-keyword">package</span> <span class="hl-keyword">safe</span>
<span class="hl-keyword">module</span> hello
<span class="hl-keyword">use</span> sys::system

<span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> main(rc: <span class="hl-type">RootCap</span>) -&gt; <span class="hl-type">i32</span> {
  <span class="hl-keyword">let</span> c = rc.mint_console()
  c.println(&quot;hello&quot;)
  <span class="hl-keyword">return</span> <span class="hl-number">0</span>
}</code></pre>
<p><code>RootCap</code> is the root authority passed to <code>main</code>. It can mint narrower</p>
<p>capabilities (console, filesystem, network, allocators).</p>
<h2>2) Language basics</h2>
<pre class="code-block"><code><span class="hl-keyword">package</span> <span class="hl-keyword">safe</span>
<span class="hl-keyword">module</span> basics

<span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> add(a: <span class="hl-type">i32</span>, b: <span class="hl-type">i32</span>) -&gt; <span class="hl-type">i32</span> {
  <span class="hl-keyword">return</span> a + b
}

<span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> main(rc: <span class="hl-type">RootCap</span>) -&gt; <span class="hl-type">i32</span> {
  <span class="hl-keyword">let</span> x = <span class="hl-number">1</span>
  <span class="hl-keyword">let</span> y: <span class="hl-type">i32</span> = <span class="hl-number">2</span>
  <span class="hl-keyword">if</span> (x &lt; y) {
    <span class="hl-keyword">return</span> add(x, y)
  } <span class="hl-keyword">else</span> {
    <span class="hl-keyword">return</span> <span class="hl-number">0</span>
  }
}</code></pre>
<p>Key syntax:</p>
<ul>
<li>Statements: <code>let</code>, assignment, <code>if</code>, <code>while</code>, <code>for</code>, <code>match</code>, <code>return</code>, <code>defer</code>.</li>
<li>Expressions: literals, calls, binary ops, unary ops, method calls.</li>
<li>Modules + imports: <code>module ...</code> and <code>use ...</code> (alias by last path segment).</li>
<li><code>for { ... }</code> is an infinite loop; <code>for i in a..b</code> is a range loop.</li>
<li>Integer arithmetic traps on overflow.</li>
<li>Variable shadowing is not allowed.</li>
</ul>
<h2>3) Control flow and pattern matching</h2>
<pre class="code-block"><code><span class="hl-keyword">package</span> <span class="hl-keyword">safe</span>
<span class="hl-keyword">module</span> match_demo

<span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> main(rc: <span class="hl-type">RootCap</span>) -&gt; <span class="hl-type">i32</span> {
  <span class="hl-keyword">let</span> flag = <span class="hl-keyword">true</span>
  <span class="hl-keyword">match</span> flag {
    <span class="hl-keyword">true</span> =&gt; { <span class="hl-keyword">return</span> <span class="hl-number">1</span> }
    <span class="hl-keyword">false</span> =&gt; { <span class="hl-keyword">return</span> <span class="hl-number">0</span> }
  }
}</code></pre>
<p>Matches must be exhaustive; use <code>_</code> to cover the rest. <code>if let</code> is a</p>
<p>single-arm match:</p>
<pre class="code-block"><code><span class="hl-keyword">if</span> <span class="hl-keyword">let</span> <span class="hl-type">Ok</span>(x) = make() {
  <span class="hl-keyword">return</span> x
} <span class="hl-keyword">else</span> {
  <span class="hl-keyword">return</span> <span class="hl-number">0</span>
}</code></pre>
<h2>4) Structs, enums, methods</h2>
<pre class="code-block"><code><span class="hl-keyword">package</span> <span class="hl-keyword">safe</span>
<span class="hl-keyword">module</span> types

<span class="hl-keyword">struct</span> Pair { left: <span class="hl-type">i32</span>, right: <span class="hl-type">i32</span> }

<span class="hl-keyword">enum</span> Color { Red, Green, Blue }

<span class="hl-keyword">impl</span> Pair {
  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> sum(self) -&gt; <span class="hl-type">i32</span> { <span class="hl-keyword">return</span> self.left + self.right }
  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> peek(self: &amp;Pair) -&gt; <span class="hl-type">i32</span> { <span class="hl-keyword">return</span> self.left }
}</code></pre>
<ul>
<li>Structs and enums are nominal types.</li>
<li>Methods are defined in <code>impl</code> blocks and lower to <code>Type__method</code> in codegen.</li>
<li>Method receivers can be <code>self</code> (move) or <code>self: &T</code> (borrow-lite, read-only).</li>
</ul>
<h2>5) Results and error flow</h2>
<p>Capable uses <code>Result<T, E></code> for recoverable errors, similar to Rust.</p>
<pre class="code-block"><code><span class="hl-keyword">package</span> <span class="hl-keyword">safe</span>
<span class="hl-keyword">module</span> results

<span class="hl-keyword">fn</span> parse() -&gt; <span class="hl-type">Result</span>&lt;<span class="hl-type">i32</span>, <span class="hl-type">i32</span>&gt; {
  <span class="hl-keyword">return</span> <span class="hl-type">Ok</span>(<span class="hl-number">7</span>)
}

<span class="hl-keyword">fn</span> use_value() -&gt; <span class="hl-type">Result</span>&lt;<span class="hl-type">i32</span>, <span class="hl-type">i32</span>&gt; {
  <span class="hl-keyword">let</span> v = parse()?
  <span class="hl-keyword">return</span> <span class="hl-type">Ok</span>(v + <span class="hl-number">1</span>)
}</code></pre>
<p>Other helpers:</p>
<pre class="code-block"><code><span class="hl-keyword">let</span> v = make().unwrap_or(<span class="hl-number">0</span>)
<span class="hl-keyword">let</span> e = make().unwrap_err_or(<span class="hl-number">0</span>)</code></pre>
<h2>6) Capabilities and attenuation</h2>
<p>Capabilities live in <code>sys.*</code> and are declared with <code>capability</code> (opaque, no</p>
<p>public fields, no user construction). You only get them from <code>RootCap</code>.</p>
<p>They are just structs, but special ones: the compiler treats capability</p>
<p>types as authority tokens, and safe code cannot forge or construct them.</p>
<p>This works because capability structs have no public fields or constructors,</p>
<p>and the compiler rejects any attempt to synthesize them outside the stdlib.</p>
<p>In other words: if you did not receive a capability value, there is no safe</p>
<p>way to manufacture one.</p>
<pre class="code-block"><code><span class="hl-keyword">package</span> <span class="hl-keyword">safe</span>
<span class="hl-keyword">module</span> read_config
<span class="hl-keyword">use</span> sys::system
<span class="hl-keyword">use</span> sys::fs

<span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> main(rc: <span class="hl-type">RootCap</span>) -&gt; <span class="hl-type">i32</span> {
  <span class="hl-keyword">let</span> fs = rc.mint_readfs(&quot;./config&quot;)
  <span class="hl-keyword">let</span> alloc = rc.mint_alloc_default()
  <span class="hl-keyword">match</span> fs.read_to_string(alloc, <span class="hl-string">&quot;app.txt&quot;</span>) {
    <span class="hl-type">Ok</span>(s) =&gt; { rc.mint_console().println(s); <span class="hl-keyword">return</span> <span class="hl-number">0</span> }
    <span class="hl-type">Err</span>(_) =&gt; { <span class="hl-keyword">return</span> <span class="hl-number">1</span> }
  }
}</code></pre>
<p>The stdlib is the only safe way to access privileged operations like the</p>
<p>filesystem or network. In <code>package safe</code>, you cannot call raw syscalls or FFI.</p>
<p>That means if a function does not receive a <code>ReadFS</code> (or <code>Net</code>, etc.), it simply</p>
<p>cannot touch those resources. This keeps permissions explicit and local.</p>
<p>If a package is marked <code>unsafe</code>, it can bypass memory safety and call raw FFI,</p>
<p>which breaks the capability model entirely. Unsafe code is therefore a huge</p>
<p>risk: it can forge or corrupt capability values, violate attenuation, or reach</p>
<p>privileged operations directly. Treat unsafe dependencies as highly trusted</p>
<p>code and use auditing/<code>--safe-only</code> to keep the boundary tight.</p>
<p>Attenuation is one-way: methods that return capabilities must take <code>self</code> by</p>
<p>value, so you give up the more powerful capability when you derive a narrower</p>
<p>one. This is enforced by the compiler.</p>
<h2>7) Kinds: copy, affine, linear</h2>
<p>Types can declare how they move:</p>
<pre class="code-block"><code><span class="hl-keyword">capability</span> <span class="hl-keyword">struct</span> Token           <span class="hl-comment">// affine by default (move-only)</span>
<span class="hl-keyword">copy</span> <span class="hl-keyword">capability</span> <span class="hl-keyword">struct</span> <span class="hl-type">RootCap</span>    <span class="hl-comment">// unrestricted (copyable)</span>
<span class="hl-keyword">linear</span> <span class="hl-keyword">capability</span> <span class="hl-keyword">struct</span> <span class="hl-type">FileRead</span> <span class="hl-comment">// must be consumed</span></code></pre>
<p>Kinds:</p>
<ul>
<li><strong>Copy</strong>: reusable.</li>
<li><strong>Affine</strong>: move-only, dropping is allowed.</li>
<li><strong>Linear</strong>: move-only and must be consumed on all paths.</li>
</ul>
<h2>8) Borrow-lite references: <code>&T</code></h2>
<p>Capable has a minimal borrow system for read-only access. The goal is to make</p>
<p>non-consuming reads ergonomic without a full borrow checker.</p>
<pre class="code-block"><code><span class="hl-keyword">impl</span> Thing {
  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> ping(self: &amp;Thing) -&gt; <span class="hl-type">i32</span> { <span class="hl-keyword">return</span> <span class="hl-number">1</span> }
}

<span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> twice(c: &amp;Thing) -&gt; <span class="hl-type">i32</span> {
  <span class="hl-keyword">let</span> a = c.ping()
  <span class="hl-keyword">let</span> b = c.ping()
  <span class="hl-keyword">return</span> a + b
}</code></pre>
<p>Rules:</p>
<ul>
<li><code>&T</code> is allowed on parameters and locals.</li>
<li>Reference locals must be initialized from another local value.</li>
<li>References cannot be stored in structs/enums or returned.</li>
<li>References are read-only.</li>
</ul>
<p>This keeps the language simple without a full borrow checker. It also keeps</p>
<p>lifetimes simple: a borrow is only valid within the current scope, so you never</p>
<p>have to reason about aliasing across function boundaries.</p>
<p>Borrow-lite is intentionally conservative. If you need shared ownership across</p>
<p>functions, pass the value by move (and return it), or design your API to do the</p>
<p>read inside the callee.</p>
<h2>9) Memory model</h2>
<p>Capable has explicit memory management. Owned heap types must be freed.</p>
<p>Non-owning views must not outlive their backing storage.</p>
<p>Owned types:</p>
<ul>
<li><code>Vec<T></code> (heap-backed)</li>
<li><code>Text</code> (owned UTF-8 bytes, backed by <code>Vec<u8></code>)</li>
</ul>
<p>Views:</p>
<ul>
<li><code>string</code> (non-owning view of bytes)</li>
<li><code>Slice<T></code>, <code>MutSlice<T></code> (non-owning views)</li>
</ul>
<p>Safe code cannot return or store slices in structs/enums, which keeps slice</p>
<p>lifetimes local until a full lifetime model exists.</p>
<h3>Allocators</h3>
<p>Allocation is explicit. Functions that allocate accept an <code>Alloc</code> handle:</p>
<pre class="code-block"><code><span class="hl-keyword">let</span> alloc = rc.mint_alloc_default()
<span class="hl-keyword">let</span> v = alloc.vec_u8_new()
...
alloc.vec_u8_free(v)</code></pre>
<p>Use <code>defer</code> to simplify cleanup.</p>
<h2>10) Strings: <code>string</code> vs <code>Text</code></h2>
<p><code>string</code> is a view. <code>Text</code> is owned.</p>
<pre class="code-block"><code><span class="hl-keyword">fn</span> build_greeting(alloc: <span class="hl-type">Alloc</span>) -&gt; <span class="hl-type">Result</span>&lt;<span class="hl-type">string</span>, buffer::AllocErr&gt; {
  <span class="hl-keyword">let</span> s = <span class="hl-string">&quot;hello&quot;</span>
  <span class="hl-keyword">let</span> _bytes = s.as_slice()
  <span class="hl-keyword">let</span> _sub = s.slice_range(<span class="hl-number">0</span>, <span class="hl-number">5</span>)?

  <span class="hl-keyword">let</span> t = alloc.text_new()
  <span class="hl-keyword">defer</span> t.free(alloc)
  t.push_str(&quot;hello&quot;)?
  t.push_byte(&#x27; &#x27;)?
  t.append(&quot;text&quot;)?
  <span class="hl-keyword">let</span> out = t.to_string()?
  <span class="hl-keyword">return</span> <span class="hl-type">Ok</span>(out)
}</code></pre>
<p>Helpers:</p>
<ul>
<li><code>string.split</code>, <code>split_once</code>, <code>trim_<em></code>, <code>contains</code>, <code>index_of_</em></code>.</li>
<li><code>string.concat(alloc, other)</code> creates a new owned string view.</li>
<li><code>Text.slice_range</code> returns a <code>string</code> view into its buffer.</li>
</ul>
<h2>11) Slices and indexing</h2>
<p>Slices are bounds-checked in safe code. Indexing out of bounds traps.</p>
<p>If you need a checked version, use <code>slice_range</code> or <code>byte_at_checked</code>.</p>
<pre class="code-block"><code><span class="hl-keyword">fn</span> use_tail(s: <span class="hl-type">string</span>) -&gt; <span class="hl-type">Result</span>&lt;<span class="hl-type">unit</span>, buffer::SliceErr&gt; {
  <span class="hl-keyword">let</span> buf = s.as_slice()
  <span class="hl-keyword">let</span> b0 = buf.at(<span class="hl-number">0</span>) <span class="hl-comment">// traps if out of bounds</span>
  <span class="hl-keyword">let</span> tail = buf.slice_range(<span class="hl-number">1</span>, <span class="hl-number">3</span>)?
  <span class="hl-keyword">let</span> _b1 = tail.at(<span class="hl-number">0</span>)
  <span class="hl-keyword">return</span> <span class="hl-type">Ok</span>(())
}</code></pre>
<h2>12) Defer (scope-based cleanup)</h2>
<p><code>defer</code> schedules a call to run when the current scope exits (LIFO order):</p>
<pre class="code-block"><code><span class="hl-keyword">let</span> c = rc.mint_console()
<span class="hl-keyword">let</span> alloc = rc.mint_alloc_default()
<span class="hl-keyword">let</span> v = alloc.vec_u8_new()

<span class="hl-comment">// ensure we free on all paths</span>
 <span class="hl-keyword">defer</span> alloc.vec_u8_free(v)</code></pre>
<p>Deferred expressions must be calls; arguments are evaluated at the defer site.</p>
<h2>13) Safe vs unsafe</h2>
<p><code>package safe</code> is default. Raw pointers and extern calls require</p>
<p><code>package unsafe</code>.</p>
<pre class="code-block"><code><span class="hl-keyword">package</span> <span class="hl-keyword">unsafe</span>
<span class="hl-keyword">module</span> pointers

<span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> main(rc: <span class="hl-type">RootCap</span>) -&gt; <span class="hl-type">i32</span> {
  <span class="hl-keyword">let</span> alloc = rc.mint_alloc_default()
  <span class="hl-keyword">let</span> p = alloc.malloc(<span class="hl-number">16</span>)
  alloc.free(p)
  <span class="hl-keyword">return</span> <span class="hl-number">0</span>
}</code></pre>
<p>Unsafe is auditable: <code>--safe-only</code> rejects unsafe dependencies, and <code>audit</code></p>
<p>reports unsafe packages.</p>
<h2>14) Putting it together: a small parser</h2>
<pre class="code-block"><code><span class="hl-keyword">enum</span> ParseErr { MissingEq, OutOfRange, Oom }

<span class="hl-keyword">fn</span> parse_key_value(line: <span class="hl-type">string</span>, alloc: <span class="hl-type">Alloc</span>) -&gt; <span class="hl-type">Result</span>&lt;<span class="hl-type">string</span>, ParseErr&gt; {
  <span class="hl-keyword">let</span> eq = <span class="hl-keyword">match</span> (line.index_of_byte(&#x27;=&#x27;)) {
    <span class="hl-type">Ok</span>(i) =&gt; { i }
    <span class="hl-type">Err</span>(_) =&gt; { <span class="hl-keyword">return</span> <span class="hl-type">Err</span>(ParseErr::MissingEq) }
  }
  <span class="hl-keyword">let</span> key = <span class="hl-keyword">match</span> (line.slice_range(<span class="hl-number">0</span>, eq)) {
    <span class="hl-type">Ok</span>(v) =&gt; { v }
    <span class="hl-type">Err</span>(_) =&gt; { <span class="hl-keyword">return</span> <span class="hl-type">Err</span>(ParseErr::OutOfRange) }
  }
  <span class="hl-keyword">let</span> val = <span class="hl-keyword">match</span> (line.slice_range(eq + <span class="hl-number">1</span>, line.len())) {
    <span class="hl-type">Ok</span>(v) =&gt; { v }
    <span class="hl-type">Err</span>(_) =&gt; { <span class="hl-keyword">return</span> <span class="hl-type">Err</span>(ParseErr::OutOfRange) }
  }

  <span class="hl-keyword">let</span> t = alloc.text_new()
  <span class="hl-keyword">defer</span> t.free(alloc)
  <span class="hl-keyword">match</span> (t.push_str(key)) {
    <span class="hl-type">Ok</span>(_) =&gt; { }
    <span class="hl-type">Err</span>(_) =&gt; { <span class="hl-keyword">return</span> <span class="hl-type">Err</span>(ParseErr::Oom) }
  }
  <span class="hl-keyword">match</span> (t.push_byte(&#x27;=&#x27;)) {
    <span class="hl-type">Ok</span>(_) =&gt; { }
    <span class="hl-type">Err</span>(_) =&gt; { <span class="hl-keyword">return</span> <span class="hl-type">Err</span>(ParseErr::Oom) }
  }
  <span class="hl-keyword">match</span> (t.push_str(val)) {
    <span class="hl-type">Ok</span>(_) =&gt; { }
    <span class="hl-type">Err</span>(_) =&gt; { <span class="hl-keyword">return</span> <span class="hl-type">Err</span>(ParseErr::Oom) }
  }
  <span class="hl-keyword">match</span> (t.to_string()) {
    <span class="hl-type">Ok</span>(out) =&gt; { <span class="hl-keyword">return</span> <span class="hl-type">Ok</span>(out) }
    <span class="hl-type">Err</span>(_) =&gt; { <span class="hl-keyword">return</span> <span class="hl-type">Err</span>(ParseErr::Oom) }
  }
}</code></pre>
<p>This pattern (find delimiter, slice views, optionally allocate) is the common</p>
<p>way to parse without raw pointers.</p>
<hr>
<h2>Where to go next</h2>
<ul>
<li>Read <code>docs/memory.md</code> and <code>docs/ABI.md</code> for deeper internals.</li>
<li>Explore <code>examples/</code> for real programs.</li>
<li>Use <code>defer</code> aggressively to keep ownership clear.</li>
</ul>
<p>Capable is intentionally small. The goal is to make capability-based security</p>
<p>and explicit memory ownership the default, not an advanced feature.</p>
      </div>
    </div>

    <!-- Stdlib Page -->
    <div id="stdlib" class="page">
      <div class="stdlib-layout">
        <div class="stdlib-nav">
          <h3>Modules</h3>
          <div id="module-list"></div>
        </div>
        <div class="stdlib-content" id="module-content">
          <p class="module-path">Select a module from the sidebar</p>
        </div>
      </div>
    </div>
  </main>

  <script>
    // Tab navigation
    const tabs = document.querySelectorAll('.tab');
    const pages = document.querySelectorAll('.page');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const pageId = tab.dataset.page;

        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        pages.forEach(p => {
          p.classList.toggle('active', p.id === pageId);
        });
      });
    });

    // Stdlib browser
    const modules = [{"path": "/Users/jm/Development/capable/stdlib/sys/args.cap", "module": "sys::args", "docs": ["Program argument access."], "items": [{"kind": "struct", "sig": "pub copy capability struct Args", "docs": ["Capability for reading argv."]}, {"kind": "enum", "sig": "pub enum ArgsErr", "docs": ["Argument lookup errors."]}, {"kind": "method", "impl": "Args", "sig": "pub fn len(self) -> i32", "docs": ["Number of arguments."]}, {"kind": "method", "impl": "Args", "sig": "pub fn at(self, index: i32) -> Result<string, ArgsErr>", "docs": ["Get an argument by index."]}], "source": "/// Program argument access.\npackage safe\nmodule sys::args\n\n/// Capability for reading argv.\npub copy capability struct Args\n\n/// Argument lookup errors.\npub enum ArgsErr {\n  /// Index was out of range.\n  OutOfRange\n}\n\nimpl Args {\n  /// Number of arguments.\n  pub fn len(self) -> i32 {\n    return 0\n  }\n\n  /// Get an argument by index.\n  pub fn at(self, index: i32) -> Result<string, ArgsErr> {\n    return Err(ArgsErr::OutOfRange)\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/buffer.cap", "module": "sys::buffer", "docs": ["Slice and allocation utilities.", "Slice/MutSlice are lightweight, non-owning views into existing bytes."], "items": [{"kind": "struct", "sig": "pub copy opaque struct Alloc", "docs": ["Alloc capability for heap operations (heap-backed allocations)."]}, {"kind": "struct", "sig": "pub copy struct Slice<T>", "docs": ["Immutable slice view (non-owning)."]}, {"kind": "struct", "sig": "pub copy struct MutSlice<T>", "docs": ["Mutable slice view (non-owning)."]}, {"kind": "enum", "sig": "pub enum AllocErr", "docs": ["Allocation errors."]}, {"kind": "enum", "sig": "pub enum SliceErr", "docs": ["Out of memory.", "Slice errors."]}, {"kind": "fn", "impl": null, "sig": "pub fn copy_slice(alloc: Alloc, data: Slice<u8>) -> Result<Slice<u8>, AllocErr>", "docs": ["Index is out of range.", "Copy a slice into a new owned slice using the provided allocator."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn malloc(self, size: i32) -> *u8", "docs": ["Allocate raw bytes."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn free(self, ptr: *u8) -> unit", "docs": ["Free raw bytes."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn cast_u8_to_u32(self, ptr: *u8) -> *u32", "docs": ["Reinterpret a *u8 as *u32."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn cast_u32_to_u8(self, ptr: *u32) -> *u8", "docs": ["Reinterpret a *u32 as *u8."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn slice_from_ptr(self, ptr: *u8, len: i32) -> Slice<u8>", "docs": ["Create an immutable slice from a raw pointer."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn mut_slice_from_ptr(self, ptr: *u8, len: i32) -> MutSlice<u8>", "docs": ["Create a mutable slice from a raw pointer."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_u8_new(self) -> vec::Vec<u8>", "docs": ["Create a Vec<u8> with this Alloc (heap-backed)."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_u8_with_capacity(self, capacity: i32) -> Result<vec::Vec<u8>, AllocErr>", "docs": ["Create a Vec<u8> with capacity using this Alloc."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_u8_free(self, v: vec::Vec<u8>) -> unit", "docs": ["Free a Vec<u8> created with this Alloc."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_i32_new(self) -> vec::Vec<i32>", "docs": ["Create a Vec<i32> with this Alloc (heap-backed)."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_i32_with_capacity(self, capacity: i32) -> Result<vec::Vec<i32>, AllocErr>", "docs": ["Create a Vec<i32> with capacity using this Alloc."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_i32_free(self, v: vec::Vec<i32>) -> unit", "docs": ["Free a Vec<i32> created with this Alloc."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_string_new(self) -> vec::Vec<string>", "docs": ["Create a Vec<string> with this Alloc (heap-backed)."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_string_with_capacity(self, capacity: i32) -> Result<vec::Vec<string>, AllocErr>", "docs": ["Create a Vec<string> with capacity using this Alloc."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_string_free(self, v: vec::Vec<string>) -> unit", "docs": ["Free a Vec<string> created with this Alloc."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn text_new(self) -> string::Text", "docs": ["Allocate a new empty Text."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn text_with_capacity(self, capacity: i32) -> Result<string::Text, AllocErr>", "docs": ["Allocate a new empty Text with capacity."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn text_from(self, s: string) -> Result<string::Text, AllocErr>", "docs": ["Copy a string view into a new Text."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_new<T>(self) -> vec::Vec<T>", "docs": ["Create a Vec<T> with this Alloc (heap-backed)."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_with_capacity<T>(self, capacity: i32) -> Result<vec::Vec<T>, AllocErr>", "docs": ["Create a Vec<T> with capacity using this Alloc."]}, {"kind": "method", "impl": "Alloc", "sig": "pub fn vec_free<T>(self, v: vec::Vec<T>) -> unit", "docs": ["Free a Vec<T> created with this Alloc."]}, {"kind": "fn", "impl": null, "sig": "pub fn len(self) -> i32", "docs": ["Length in elements."]}, {"kind": "fn", "impl": null, "sig": "pub fn slice(self, start: i32, len: i32) -> Result<Slice<T>, SliceErr>", "docs": ["Create a subslice view."]}, {"kind": "fn", "impl": null, "sig": "pub fn slice_range(self, start: i32, end: i32) -> Result<Slice<T>, SliceErr>", "docs": ["Create a subslice view using start/end bounds (end is exclusive)."]}, {"kind": "fn", "impl": null, "sig": "pub fn len(self) -> i32", "docs": ["Length in elements."]}, {"kind": "fn", "impl": null, "sig": "pub fn slice(self, start: i32, len: i32) -> Result<MutSlice<T>, SliceErr>", "docs": ["Create a mutable subslice view."]}, {"kind": "fn", "impl": null, "sig": "pub fn slice_range(self, start: i32, end: i32) -> Result<MutSlice<T>, SliceErr>", "docs": ["Create a mutable subslice view using start/end bounds (end is exclusive)."]}, {"kind": "method", "impl": "Slice<u8>", "sig": "pub fn at(self, i: i32) -> u8", "docs": ["Index into the slice."]}, {"kind": "method", "impl": "MutSlice<u8>", "sig": "pub fn at(self, i: i32) -> u8", "docs": ["Index into the mutable slice."]}], "source": "/// Slice and allocation utilities.\n/// Slice/MutSlice are lightweight, non-owning views into existing bytes.\npackage safe\nmodule sys::buffer\nuse sys::vec\nuse sys::string\nuse sys::unsafe_ptr\n\n/// Alloc capability for heap operations (heap-backed allocations).\npub copy opaque struct Alloc\n/// Immutable slice view (non-owning).\npub copy struct Slice<T> {\n  ptr: *T,\n  len: i32\n}\n/// Mutable slice view (non-owning).\npub copy struct MutSlice<T> {\n  ptr: *T,\n  len: i32\n}\n\n/// Allocation errors.\npub enum AllocErr {\n  /// Out of memory.\n  Oom\n}\n\n/// Slice errors.\npub enum SliceErr {\n  /// Index is out of range.\n  OutOfRange\n}\n\n/// Copy a slice into a new owned slice using the provided allocator.\npub fn copy_slice(alloc: Alloc, data: Slice<u8>) -> Result<Slice<u8>, AllocErr> {\n  let len = data.len()\n  let raw = alloc.malloc(len)\n  if (len > 0 && unsafe_ptr::ptr_is_null<u8>(raw)) {\n    return Err(AllocErr::Oom)\n  }\n  let i = 0\n  while (i < len) {\n    let value = data.at(i)\n    unsafe_ptr::ptr_write<u8>(unsafe_ptr::ptr_add<u8>(raw, i), value)\n    i = i + 1\n  }\n  return Ok(alloc.slice_from_ptr(raw, len))\n}\n\nimpl Alloc {\n  /// Allocate raw bytes.\n  pub fn malloc(self, size: i32) -> *u8 {\n    return ()\n  }\n\n  /// Free raw bytes.\n  pub fn free(self, ptr: *u8) -> unit {\n    return ()\n  }\n\n  /// Reinterpret a *u8 as *u32.\n  pub fn cast_u8_to_u32(self, ptr: *u8) -> *u32 {\n    return ()\n  }\n\n  /// Reinterpret a *u32 as *u8.\n  pub fn cast_u32_to_u8(self, ptr: *u32) -> *u8 {\n    return ()\n  }\n\n  /// Create an immutable slice from a raw pointer.\n  pub fn slice_from_ptr(self, ptr: *u8, len: i32) -> Slice<u8> {\n    return Slice<u8> { ptr: ptr, len: len }\n  }\n\n  /// Create a mutable slice from a raw pointer.\n  pub fn mut_slice_from_ptr(self, ptr: *u8, len: i32) -> MutSlice<u8> {\n    return MutSlice<u8> { ptr: ptr, len: len }\n  }\n\n  /// Create a Vec<u8> with this Alloc (heap-backed).\n  pub fn vec_u8_new(self) -> vec::Vec<u8> {\n    return vec::new_with<u8>(self)\n  }\n\n  /// Create a Vec<u8> with capacity using this Alloc.\n  pub fn vec_u8_with_capacity(self, capacity: i32) -> Result<vec::Vec<u8>, AllocErr> {\n    return vec::with_capacity<u8>(self, capacity)\n  }\n\n  /// Free a Vec<u8> created with this Alloc.\n  pub fn vec_u8_free(self, v: vec::Vec<u8>) -> unit {\n    v.free()\n    return ()\n  }\n\n  /// Create a Vec<i32> with this Alloc (heap-backed).\n  pub fn vec_i32_new(self) -> vec::Vec<i32> {\n    return vec::new_with<i32>(self)\n  }\n\n  /// Create a Vec<i32> with capacity using this Alloc.\n  pub fn vec_i32_with_capacity(self, capacity: i32) -> Result<vec::Vec<i32>, AllocErr> {\n    return vec::with_capacity<i32>(self, capacity)\n  }\n\n  /// Free a Vec<i32> created with this Alloc.\n  pub fn vec_i32_free(self, v: vec::Vec<i32>) -> unit {\n    v.free()\n    return ()\n  }\n\n  /// Create a Vec<string> with this Alloc (heap-backed).\n  pub fn vec_string_new(self) -> vec::Vec<string> {\n    return vec::new_with<string>(self)\n  }\n\n  /// Create a Vec<string> with capacity using this Alloc.\n  pub fn vec_string_with_capacity(self, capacity: i32) -> Result<vec::Vec<string>, AllocErr> {\n    return vec::with_capacity<string>(self, capacity)\n  }\n\n  /// Free a Vec<string> created with this Alloc.\n  pub fn vec_string_free(self, v: vec::Vec<string>) -> unit {\n    v.free()\n    return ()\n  }\n\n  /// Allocate a new empty Text.\n  pub fn text_new(self) -> string::Text {\n    return string::text_new(self)\n  }\n\n  /// Allocate a new empty Text with capacity.\n  pub fn text_with_capacity(self, capacity: i32) -> Result<string::Text, AllocErr> {\n    return string::text_with_capacity(self, capacity)\n  }\n\n  /// Copy a string view into a new Text.\n  pub fn text_from(self, s: string) -> Result<string::Text, AllocErr> {\n    return string::text_from(self, s)\n  }\n\n  /// Create a Vec<T> with this Alloc (heap-backed).\n  pub fn vec_new<T>(self) -> vec::Vec<T> {\n    return vec::new_with<T>(self)\n  }\n\n  /// Create a Vec<T> with capacity using this Alloc.\n  pub fn vec_with_capacity<T>(self, capacity: i32) -> Result<vec::Vec<T>, AllocErr> {\n    return vec::with_capacity<T>(self, capacity)\n  }\n\n  /// Free a Vec<T> created with this Alloc.\n  pub fn vec_free<T>(self, v: vec::Vec<T>) -> unit {\n    v.free()\n    return ()\n  }\n}\n\nimpl<T> Slice<T> {\n  /// Length in elements.\n  pub fn len(self) -> i32 {\n    return self.len\n  }\n\n  /// Create a subslice view.\n  pub fn slice(self, start: i32, len: i32) -> Result<Slice<T>, SliceErr> {\n    if (start < 0 || len < 0) {\n      return Err(SliceErr::OutOfRange)\n    }\n    if (start > self.len) {\n      return Err(SliceErr::OutOfRange)\n    }\n    if (start + len > self.len) {\n      return Err(SliceErr::OutOfRange)\n    }\n    let ptr = unsafe_ptr::ptr_add<T>(self.ptr, start)\n    return Ok(Slice<T> { ptr: ptr, len: len })\n  }\n\n  /// Create a subslice view using start/end bounds (end is exclusive).\n  pub fn slice_range(self, start: i32, end: i32) -> Result<Slice<T>, SliceErr> {\n    if (start < 0 || end < 0) {\n      return Err(SliceErr::OutOfRange)\n    }\n    if (start > end) {\n      return Err(SliceErr::OutOfRange)\n    }\n    return self.slice(start, end - start)\n  }\n}\n\nimpl<T> MutSlice<T> {\n  /// Length in elements.\n  pub fn len(self) -> i32 {\n    return self.len\n  }\n\n  /// Create a mutable subslice view.\n  pub fn slice(self, start: i32, len: i32) -> Result<MutSlice<T>, SliceErr> {\n    if (start < 0 || len < 0) {\n      return Err(SliceErr::OutOfRange)\n    }\n    if (start > self.len) {\n      return Err(SliceErr::OutOfRange)\n    }\n    if (start + len > self.len) {\n      return Err(SliceErr::OutOfRange)\n    }\n    let ptr = unsafe_ptr::ptr_add<T>(self.ptr, start)\n    return Ok(MutSlice<T> { ptr: ptr, len: len })\n  }\n\n  /// Create a mutable subslice view using start/end bounds (end is exclusive).\n  pub fn slice_range(self, start: i32, end: i32) -> Result<MutSlice<T>, SliceErr> {\n    if (start < 0 || end < 0) {\n      return Err(SliceErr::OutOfRange)\n    }\n    if (start > end) {\n      return Err(SliceErr::OutOfRange)\n    }\n    return self.slice(start, end - start)\n  }\n}\n\nimpl Slice<u8> {\n  /// Index into the slice.\n  pub fn at(self, i: i32) -> u8 {\n    if (i < 0 || i >= self.len) {\n      panic()\n    }\n    let ptr = unsafe_ptr::ptr_add<u8>(self.ptr, i)\n    return unsafe_ptr::ptr_read<u8>(ptr)\n  }\n}\n\nimpl MutSlice<u8> {\n  /// Index into the mutable slice.\n  pub fn at(self, i: i32) -> u8 {\n    if (i < 0 || i >= self.len) {\n      panic()\n    }\n    let ptr = unsafe_ptr::ptr_add<u8>(self.ptr, i)\n    return unsafe_ptr::ptr_read<u8>(ptr)\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/bytes.cap", "module": "sys::bytes", "docs": ["Byte helpers and predicates."], "items": [{"kind": "method", "impl": "u8", "sig": "pub fn is_whitespace(self) -> bool", "docs": ["True if the byte is ASCII whitespace."]}], "source": "/// Byte helpers and predicates.\npackage safe\nmodule sys::bytes\nimpl u8 {\n  /// True if the byte is ASCII whitespace.\n  pub fn is_whitespace(self) -> bool {\n    if (self == ' ' || self == '\\t' || self == '\\n' || self == '\\r') {\n      return true\n    }\n    return false\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/console.cap", "module": "sys::console", "docs": ["Console output utilities."], "items": [{"kind": "struct", "sig": "pub copy capability struct Console", "docs": ["Capability for stdout access."]}, {"kind": "method", "impl": "Console", "sig": "pub fn print(self, s: string) -> unit", "docs": ["Print a string without a newline."]}, {"kind": "method", "impl": "Console", "sig": "pub fn println(self, s: string) -> unit", "docs": ["Print a string with a newline."]}, {"kind": "method", "impl": "Console", "sig": "pub fn print_i32(self, v: i32) -> unit", "docs": ["Print an i32 without a newline."]}, {"kind": "method", "impl": "Console", "sig": "pub fn println_i32(self, v: i32) -> unit", "docs": ["Print an i32 with a newline."]}, {"kind": "method", "impl": "Console", "sig": "pub fn assert(self, cond: bool) -> unit", "docs": ["Trap if condition is false."]}], "source": "/// Console output utilities.\npackage unsafe\nmodule sys::console\n\n/// Capability for stdout access.\npub copy capability struct Console\n\nimpl Console {\n  /// Print a string without a newline.\n  pub fn print(self, s: string) -> unit {\n    return ()\n  }\n\n  /// Print a string with a newline.\n  pub fn println(self, s: string) -> unit {\n    return ()\n  }\n\n  /// Print an i32 without a newline.\n  pub fn print_i32(self, v: i32) -> unit {\n    return ()\n  }\n\n  /// Print an i32 with a newline.\n  pub fn println_i32(self, v: i32) -> unit {\n    return ()\n  }\n\n  /// Trap if condition is false.\n  pub fn assert(self, cond: bool) -> unit {\n    return ()\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/fs.cap", "module": "sys::fs", "docs": ["Filesystem capabilities and helpers."], "items": [{"kind": "struct", "sig": "pub capability struct ReadFS", "docs": ["Read-only filesystem capability."]}, {"kind": "struct", "sig": "pub capability struct Filesystem", "docs": ["Read/write filesystem capability."]}, {"kind": "struct", "sig": "pub capability struct Dir", "docs": ["Directory capability."]}, {"kind": "struct", "sig": "pub linear capability struct FileRead", "docs": ["File handle for reading; linear to enforce close."]}, {"kind": "enum", "sig": "pub enum FsErr { NotFound, PermissionDenied, InvalidPath, IoError }", "docs": ["Filesystem error codes."]}, {"kind": "method", "impl": "ReadFS", "sig": "pub fn read_to_string(self, alloc: buffer::Alloc, path: string) -> Result<string, FsErr>", "docs": ["Read an entire file into a string."]}, {"kind": "method", "impl": "ReadFS", "sig": "pub fn read_bytes(self, alloc: buffer::Alloc, path: string) -> Result<vec::Vec<u8>, FsErr>", "docs": ["Read an entire file into a byte vec."]}, {"kind": "method", "impl": "ReadFS", "sig": "pub fn list_dir(self, alloc: buffer::Alloc, path: string) -> Result<vec::Vec<string>, FsErr>", "docs": ["List directory contents as strings."]}, {"kind": "method", "impl": "ReadFS", "sig": "pub fn exists(self, path: string) -> bool", "docs": ["True if a path exists."]}, {"kind": "method", "impl": "ReadFS", "sig": "pub fn close(self) -> unit", "docs": ["Close the capability."]}, {"kind": "method", "impl": "Filesystem", "sig": "pub fn root_dir(self) -> Dir", "docs": ["Get a Dir for the filesystem root."]}, {"kind": "method", "impl": "Filesystem", "sig": "pub fn close(self) -> unit", "docs": ["Close the capability."]}, {"kind": "method", "impl": "Dir", "sig": "pub fn subdir(self, name: string) -> Dir", "docs": ["Open a subdirectory."]}, {"kind": "method", "impl": "Dir", "sig": "pub fn open_read(self, name: string) -> FileRead", "docs": ["Open a file for reading."]}, {"kind": "method", "impl": "Dir", "sig": "pub fn read_bytes(self, alloc: buffer::Alloc, name: string) -> Result<vec::Vec<u8>, FsErr>", "docs": ["Read a file into a byte vec."]}, {"kind": "method", "impl": "Dir", "sig": "pub fn list_dir(self, alloc: buffer::Alloc) -> Result<vec::Vec<string>, FsErr>", "docs": ["List directory contents."]}, {"kind": "method", "impl": "Dir", "sig": "pub fn exists(self, name: string) -> bool", "docs": ["True if a path exists."]}, {"kind": "method", "impl": "Dir", "sig": "pub fn read_to_string(self, alloc: buffer::Alloc, name: string) -> Result<string, FsErr>", "docs": ["Read a file into a string."]}, {"kind": "method", "impl": "Dir", "sig": "pub fn close(self) -> unit", "docs": ["Close the capability."]}, {"kind": "method", "impl": "FileRead", "sig": "pub fn read_to_string(self, alloc: buffer::Alloc) -> Result<string, FsErr>", "docs": ["Read the file into a string."]}, {"kind": "method", "impl": "FileRead", "sig": "pub fn close(self) -> unit", "docs": ["Close the file."]}, {"kind": "fn", "impl": null, "sig": "pub fn join(alloc: buffer::Alloc, a: string, b: string) -> string", "docs": ["Join two path segments with a platform separator."]}], "source": "/// Filesystem capabilities and helpers.\npackage unsafe\nmodule sys::fs\n\nuse sys::buffer\nuse sys::vec\n\n/// Read-only filesystem capability.\npub capability struct ReadFS\n/// Read/write filesystem capability.\npub capability struct Filesystem\n/// Directory capability.\npub capability struct Dir\n/// File handle for reading; linear to enforce close.\npub linear capability struct FileRead\n\n/// Filesystem error codes.\npub enum FsErr { NotFound, PermissionDenied, InvalidPath, IoError }\n\nimpl ReadFS {\n  /// Read an entire file into a string.\n  pub fn read_to_string(self, alloc: buffer::Alloc, path: string) -> Result<string, FsErr> {\n    return ()\n  }\n\n  /// Read an entire file into a byte vec.\n  pub fn read_bytes(self, alloc: buffer::Alloc, path: string) -> Result<vec::Vec<u8>, FsErr> {\n    return Err(FsErr::IoError)\n  }\n\n  /// List directory contents as strings.\n  pub fn list_dir(self, alloc: buffer::Alloc, path: string) -> Result<vec::Vec<string>, FsErr> {\n    return Err(FsErr::IoError)\n  }\n\n  /// True if a path exists.\n  pub fn exists(self, path: string) -> bool {\n    return false\n  }\n\n  /// Close the capability.\n  pub fn close(self) -> unit {\n    return ()\n  }\n}\n\nimpl Filesystem {\n  /// Get a Dir for the filesystem root.\n  pub fn root_dir(self) -> Dir {\n    return ()\n  }\n\n  /// Close the capability.\n  pub fn close(self) -> unit {\n    return ()\n  }\n}\n\nimpl Dir {\n  /// Open a subdirectory.\n  pub fn subdir(self, name: string) -> Dir {\n    return ()\n  }\n\n  /// Open a file for reading.\n  pub fn open_read(self, name: string) -> FileRead {\n    return ()\n  }\n\n  /// Read a file into a byte vec.\n  pub fn read_bytes(self, alloc: buffer::Alloc, name: string) -> Result<vec::Vec<u8>, FsErr> {\n    return Err(FsErr::IoError)\n  }\n\n  /// List directory contents.\n  pub fn list_dir(self, alloc: buffer::Alloc) -> Result<vec::Vec<string>, FsErr> {\n    return Err(FsErr::IoError)\n  }\n\n  /// True if a path exists.\n  pub fn exists(self, name: string) -> bool {\n    return false\n  }\n\n  /// Read a file into a string.\n  pub fn read_to_string(self, alloc: buffer::Alloc, name: string) -> Result<string, FsErr> {\n    let file = self.open_read(name)\n    return file.read_to_string(alloc)\n  }\n\n  /// Close the capability.\n  pub fn close(self) -> unit {\n    return ()\n  }\n}\n\nimpl FileRead {\n  /// Read the file into a string.\n  pub fn read_to_string(self, alloc: buffer::Alloc) -> Result<string, FsErr> {\n    return ()\n  }\n\n  /// Close the file.\n  pub fn close(self) -> unit {\n    return ()\n  }\n}\n\n/// Join two path segments with a platform separator.\npub fn join(alloc: buffer::Alloc, a: string, b: string) -> string {\n  return \"\"\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/io.cap", "module": "sys::io", "docs": ["IO error enums shared across modules."], "items": [{"kind": "enum", "sig": "pub enum IoErr", "docs": ["Basic IO errors."]}], "source": "/// IO error enums shared across modules.\npackage safe\nmodule sys::io\n\n/// Basic IO errors.\npub enum IoErr {\n  /// Generic IO failure.\n  IoError\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/math.cap", "module": "sys::math", "docs": ["Wrapping arithmetic helpers."], "items": [{"kind": "fn", "impl": null, "sig": "pub fn add_wrap_i32(a: i32, b: i32) -> i32 { return 0 }", "docs": ["Wrapping add for i32."]}, {"kind": "fn", "impl": null, "sig": "pub fn sub_wrap_i32(a: i32, b: i32) -> i32 { return 0 }", "docs": ["Wrapping subtract for i32."]}, {"kind": "fn", "impl": null, "sig": "pub fn mul_wrap_i32(a: i32, b: i32) -> i32 { return 0 }", "docs": ["Wrapping multiply for i32."]}, {"kind": "fn", "impl": null, "sig": "pub fn add_wrap_u32(a: u32, b: u32) -> u32 { return 0 }", "docs": ["Wrapping add for u32."]}, {"kind": "fn", "impl": null, "sig": "pub fn sub_wrap_u32(a: u32, b: u32) -> u32 { return 0 }", "docs": ["Wrapping subtract for u32."]}, {"kind": "fn", "impl": null, "sig": "pub fn mul_wrap_u32(a: u32, b: u32) -> u32 { return 0 }", "docs": ["Wrapping multiply for u32."]}, {"kind": "fn", "impl": null, "sig": "pub fn add_wrap_u8(a: u8, b: u8) -> u8 { return 0 }", "docs": ["Wrapping add for u8."]}, {"kind": "fn", "impl": null, "sig": "pub fn sub_wrap_u8(a: u8, b: u8) -> u8 { return 0 }", "docs": ["Wrapping subtract for u8."]}, {"kind": "fn", "impl": null, "sig": "pub fn mul_wrap_u8(a: u8, b: u8) -> u8 { return 0 }", "docs": ["Wrapping multiply for u8."]}], "source": "/// Wrapping arithmetic helpers.\npackage safe\nmodule sys::math\n\n/// Wrapping add for i32.\npub fn add_wrap_i32(a: i32, b: i32) -> i32 { return 0 }\n/// Wrapping subtract for i32.\npub fn sub_wrap_i32(a: i32, b: i32) -> i32 { return 0 }\n/// Wrapping multiply for i32.\npub fn mul_wrap_i32(a: i32, b: i32) -> i32 { return 0 }\n\n/// Wrapping add for u32.\npub fn add_wrap_u32(a: u32, b: u32) -> u32 { return 0 }\n/// Wrapping subtract for u32.\npub fn sub_wrap_u32(a: u32, b: u32) -> u32 { return 0 }\n/// Wrapping multiply for u32.\npub fn mul_wrap_u32(a: u32, b: u32) -> u32 { return 0 }\n\n/// Wrapping add for u8.\npub fn add_wrap_u8(a: u8, b: u8) -> u8 { return 0 }\n/// Wrapping subtract for u8.\npub fn sub_wrap_u8(a: u8, b: u8) -> u8 { return 0 }\n/// Wrapping multiply for u8.\npub fn mul_wrap_u8(a: u8, b: u8) -> u8 { return 0 }\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/mem.cap", "module": "sys::mem", "docs": ["Memory helpers (reserved for future use)."], "items": [], "source": "/// Memory helpers (reserved for future use).\npackage unsafe\nmodule sys::mem\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/net.cap", "module": "sys::net", "docs": ["Networking capabilities and helpers."], "items": [{"kind": "struct", "sig": "pub copy capability struct Net", "docs": ["Network capability."]}, {"kind": "struct", "sig": "pub copy capability struct TcpListener", "docs": ["TCP listener capability."]}, {"kind": "struct", "sig": "pub linear capability struct TcpConn", "docs": ["TCP connection capability (linear to enforce close)."]}, {"kind": "enum", "sig": "pub enum NetErr", "docs": ["Network errors."]}, {"kind": "method", "impl": "Net", "sig": "pub fn listen(self, host: string, port: i32) -> Result<TcpListener, NetErr>", "docs": ["Bind and listen on host:port."]}, {"kind": "method", "impl": "Net", "sig": "pub fn connect(self, host: string, port: i32) -> Result<TcpConn, NetErr>", "docs": ["Connect to host:port."]}, {"kind": "method", "impl": "TcpListener", "sig": "pub fn accept(self: &TcpListener) -> Result<TcpConn, NetErr>", "docs": ["Accept an incoming connection."]}, {"kind": "method", "impl": "TcpListener", "sig": "pub fn close(self) -> unit", "docs": ["Close the listener."]}, {"kind": "method", "impl": "TcpConn", "sig": "pub fn read_to_string(self: &TcpConn, alloc: buffer::Alloc) -> Result<string, NetErr>", "docs": ["Read all available data into a string."]}, {"kind": "method", "impl": "TcpConn", "sig": "pub fn read(self: &TcpConn, alloc: buffer::Alloc, max_size: i32) -> Result<string, NetErr>", "docs": ["Read up to max_size bytes into a string."]}, {"kind": "method", "impl": "TcpConn", "sig": "pub fn write(self: &TcpConn, data: string) -> Result<unit, NetErr>", "docs": ["Write a string to the connection."]}, {"kind": "method", "impl": "TcpConn", "sig": "pub fn close(self) -> unit", "docs": ["Close the connection."]}], "source": "/// Networking capabilities and helpers.\npackage unsafe\nmodule sys::net\nuse sys::buffer\n\n/// Network capability.\npub copy capability struct Net\n/// TCP listener capability.\npub copy capability struct TcpListener\n/// TCP connection capability (linear to enforce close).\npub linear capability struct TcpConn\n\n/// Network errors.\npub enum NetErr {\n  /// Address parse/format error.\n  InvalidAddress,\n  /// Generic IO failure.\n  IoError,\n  /// Data parse/format error.\n  InvalidData\n}\n\nimpl Net {\n  /// Bind and listen on host:port.\n  pub fn listen(self, host: string, port: i32) -> Result<TcpListener, NetErr> {\n    return Err(NetErr::IoError)\n  }\n\n  /// Connect to host:port.\n  pub fn connect(self, host: string, port: i32) -> Result<TcpConn, NetErr> {\n    return Err(NetErr::IoError)\n  }\n}\n\nimpl TcpListener {\n  /// Accept an incoming connection.\n  pub fn accept(self: &TcpListener) -> Result<TcpConn, NetErr> {\n    return Err(NetErr::IoError)\n  }\n\n  /// Close the listener.\n  pub fn close(self) -> unit {\n    return ()\n  }\n}\n\nimpl TcpConn {\n  /// Read all available data into a string.\n  pub fn read_to_string(self: &TcpConn, alloc: buffer::Alloc) -> Result<string, NetErr> {\n    return Err(NetErr::IoError)\n  }\n\n  /// Read up to max_size bytes into a string.\n  pub fn read(self: &TcpConn, alloc: buffer::Alloc, max_size: i32) -> Result<string, NetErr> {\n    return Err(NetErr::IoError)\n  }\n\n  /// Write a string to the connection.\n  pub fn write(self: &TcpConn, data: string) -> Result<unit, NetErr> {\n    return Err(NetErr::IoError)\n  }\n\n  /// Close the connection.\n  pub fn close(self) -> unit {\n    return ()\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/option.cap", "module": "sys::option", "docs": ["Option enum and helpers."], "items": [{"kind": "enum", "sig": "pub enum Option<T>", "docs": ["Optional value."]}, {"kind": "fn", "impl": null, "sig": "pub fn is_some(self) -> bool", "docs": ["Some value.", "No value.", "True if Some."]}, {"kind": "fn", "impl": null, "sig": "pub fn is_none(self) -> bool", "docs": ["True if None."]}, {"kind": "fn", "impl": null, "sig": "pub fn unwrap_or(self, default: T) -> T", "docs": ["Return the inner value or a default."]}, {"kind": "fn", "impl": null, "sig": "pub fn unwrap(self) -> T", "docs": ["Unwrap the inner value or panic."]}], "source": "/// Option enum and helpers.\npackage safe\nmodule sys::option\n\n/// Optional value.\npub enum Option<T> {\n  /// Some value.\n  Some(T),\n  /// No value.\n  None\n}\n\nimpl<T> Option<T> {\n  /// True if Some.\n  pub fn is_some(self) -> bool {\n    match self {\n      Option::Some(_) => { return true }\n      Option::None => { return false }\n    }\n  }\n\n  /// True if None.\n  pub fn is_none(self) -> bool {\n    match self {\n      Option::Some(_) => { return false }\n      Option::None => { return true }\n    }\n  }\n\n  /// Return the inner value or a default.\n  pub fn unwrap_or(self, default: T) -> T {\n    match self {\n      Option::Some(val) => { return val }\n      Option::None => { return default }\n    }\n  }\n\n  /// Unwrap the inner value or panic.\n  pub fn unwrap(self) -> T {\n    match self {\n      Option::Some(val) => { return val }\n      Option::None => { panic() }\n    }\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/result.cap", "module": "sys::result", "docs": ["Result enum and helpers."], "items": [{"kind": "enum", "sig": "pub enum Result<T, E>", "docs": ["Result for fallible operations."]}, {"kind": "fn", "impl": null, "sig": "pub fn is_ok(self) -> bool", "docs": ["Success value.", "Error value.", "True if Ok."]}, {"kind": "fn", "impl": null, "sig": "pub fn is_err(self) -> bool", "docs": ["True if Err."]}, {"kind": "fn", "impl": null, "sig": "pub fn unwrap_or(self, default: T) -> T", "docs": ["Return Ok value or a default."]}, {"kind": "fn", "impl": null, "sig": "pub fn unwrap_err_or(self, default: E) -> E", "docs": ["Return Err value or a default."]}, {"kind": "fn", "impl": null, "sig": "pub fn ok(self) -> T", "docs": ["Unwrap Ok or panic."]}, {"kind": "fn", "impl": null, "sig": "pub fn err(self) -> E", "docs": ["Unwrap Err or panic."]}], "source": "/// Result enum and helpers.\npackage safe\nmodule sys::result\n\n/// Result for fallible operations.\npub enum Result<T, E> {\n  /// Success value.\n  Ok(T),\n  /// Error value.\n  Err(E)\n}\n\nimpl<T, E> Result<T, E> {\n  /// True if Ok.\n  pub fn is_ok(self) -> bool {\n    match self {\n      Result::Ok(_) => { return true }\n      Result::Err(_) => { return false }\n    }\n  }\n\n  /// True if Err.\n  pub fn is_err(self) -> bool {\n    match self {\n      Result::Ok(_) => { return false }\n      Result::Err(_) => { return true }\n    }\n  }\n\n  /// Return Ok value or a default.\n  pub fn unwrap_or(self, default: T) -> T {\n    match self {\n      Result::Ok(val) => { return val }\n      Result::Err(_) => { return default }\n    }\n  }\n\n  /// Return Err value or a default.\n  pub fn unwrap_err_or(self, default: E) -> E {\n    match self {\n      Result::Ok(_) => { return default }\n      Result::Err(err) => { return err }\n    }\n  }\n\n  /// Unwrap Ok or panic.\n  pub fn ok(self) -> T {\n    match self {\n      Result::Ok(val) => { return val }\n      Result::Err(_) => { panic() }\n    }\n  }\n\n  /// Unwrap Err or panic.\n  pub fn err(self) -> E {\n    match self {\n      Result::Ok(_) => { panic() }\n      Result::Err(err) => { return err }\n    }\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/stdin.cap", "module": "sys::stdin", "docs": ["Stdin access."], "items": [{"kind": "struct", "sig": "pub capability struct Stdin", "docs": ["Capability for stdin."]}, {"kind": "method", "impl": "Stdin", "sig": "pub fn read_to_string(self, alloc: buffer::Alloc) -> Result<string, io::IoErr>", "docs": ["Read stdin into a string."]}], "source": "/// Stdin access.\npackage safe\nmodule sys::stdin\n\nuse sys::io\nuse sys::buffer\n\n/// Capability for stdin.\npub capability struct Stdin\n\nimpl Stdin {\n  /// Read stdin into a string.\n  pub fn read_to_string(self, alloc: buffer::Alloc) -> Result<string, io::IoErr> {\n    return Err(io::IoErr::IoError)\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/string.cap", "module": "sys::string", "docs": ["UTF-8-ish string types.", "`string` is a lightweight view backed by a byte slice.", "`Text` is an owned, growable UTF-8 buffer backed by Vec<u8>."], "items": [{"kind": "struct", "sig": "pub copy struct string", "docs": ["String view backed by a byte slice (non-owning)."]}, {"kind": "struct", "sig": "pub struct Text", "docs": ["Owned UTF-8 text backed by a Vec<u8>.", "Text is a growable, heap-backed string builder."]}, {"kind": "struct", "sig": "pub struct SplitOnce", "docs": ["Result payload for split_once."]}, {"kind": "fn", "impl": null, "sig": "pub fn from_bytes(bytes: Slice<u8>) -> Result<string, buffer::AllocErr>", "docs": ["Wrap a slice as a string view (no copy).", "The view is only valid while the slice's backing storage is alive."]}, {"kind": "fn", "impl": null, "sig": "pub fn from_bytes_copy(alloc: buffer::Alloc, bytes: Slice<u8>) -> Result<string, buffer::AllocErr>", "docs": ["Copy a slice into a new owned string view using the provided allocator."]}, {"kind": "fn", "impl": null, "sig": "pub fn text_new(alloc: buffer::Alloc) -> Text", "docs": ["Allocate a new empty Text using the provided allocator."]}, {"kind": "fn", "impl": null, "sig": "pub fn text_with_capacity(alloc: buffer::Alloc, capacity: i32) -> Result<Text, buffer::AllocErr>", "docs": ["Allocate a new empty Text with capacity using the provided allocator."]}, {"kind": "fn", "impl": null, "sig": "pub fn text_from(alloc: buffer::Alloc, s: string) -> Result<Text, buffer::AllocErr>", "docs": ["Copy a string view into a new Text using the provided allocator."]}, {"kind": "fn", "impl": null, "sig": "fn build_range(alloc: buffer::Alloc, s: string, start: i32, end: i32) -> string", "docs": []}, {"kind": "fn", "impl": null, "sig": "fn lower_ascii_byte(b: u8) -> u8", "docs": []}, {"kind": "fn", "impl": null, "sig": "fn upper_ascii_byte(b: u8) -> u8", "docs": []}, {"kind": "method", "impl": "Text", "sig": "pub fn len(self) -> i32", "docs": ["Current length in bytes."]}, {"kind": "method", "impl": "Text", "sig": "pub fn is_empty(self) -> bool", "docs": ["True if empty."]}, {"kind": "method", "impl": "Text", "sig": "pub fn push_byte(self, b: u8) -> Result<unit, buffer::AllocErr>", "docs": ["Append a single byte.", "Bytes are not validated as UTF-8; use with ASCII or known UTF-8 bytes."]}, {"kind": "method", "impl": "Text", "sig": "pub fn extend_slice(self, data: Slice<u8>) -> Result<unit, buffer::AllocErr>", "docs": ["Append bytes from a slice.", "Bytes are not validated as UTF-8; use with ASCII or known UTF-8 bytes."]}, {"kind": "method", "impl": "Text", "sig": "pub fn extend_vec(self, data: vec::Vec<u8>) -> Result<unit, buffer::AllocErr>", "docs": ["Append bytes from a Vec<u8>."]}, {"kind": "method", "impl": "Text", "sig": "pub fn push_str(self, s: string) -> Result<unit, buffer::AllocErr>", "docs": ["Append bytes from a string view.", "This preserves the UTF-8 bytes of the view."]}, {"kind": "method", "impl": "Text", "sig": "pub fn append(self, s: string) -> Result<unit, buffer::AllocErr>", "docs": ["Append a string view (alias of push_str)."]}, {"kind": "method", "impl": "Text", "sig": "pub fn as_slice(self) -> Slice<u8>", "docs": ["Borrow as a byte slice view (no copy)."]}, {"kind": "method", "impl": "Text", "sig": "pub fn as_string(self) -> string", "docs": ["Borrow as a string view (no copy).", "The view is invalid after freeing this Text."]}, {"kind": "method", "impl": "Text", "sig": "pub fn slice_range(self, start: i32, end: i32) -> Result<string, buffer::SliceErr>", "docs": ["Borrow a subslice of this Text as a string view (byte offsets, end exclusive).", "The view is invalid after freeing this Text."]}, {"kind": "method", "impl": "Text", "sig": "pub fn to_string(self) -> Result<string, buffer::AllocErr>", "docs": ["Copy contents into a new string view.", "This allocates a new owned slice for the string view."]}, {"kind": "method", "impl": "Text", "sig": "pub fn free(self, alloc: buffer::Alloc) -> unit", "docs": ["Free the underlying Vec<u8>.", "All derived views become invalid after this call."]}, {"kind": "method", "impl": "Text", "sig": "pub fn clear(self) -> unit", "docs": ["Remove all bytes from this Text."]}, {"kind": "method", "impl": "string", "sig": "pub fn len(self) -> i32", "docs": ["Return the length in bytes."]}, {"kind": "method", "impl": "string", "sig": "pub fn slice(self, start: i32, len: i32) -> Result<string, buffer::SliceErr>", "docs": ["Create a subslice view of this string by byte offset.", "The view is invalid if the backing storage is freed."]}, {"kind": "method", "impl": "string", "sig": "pub fn slice_range(self, start: i32, end: i32) -> Result<string, buffer::SliceErr>", "docs": ["Create a subslice view of this string using start/end bounds (end exclusive).", "Offsets are byte indices (no UTF-8 validation)."]}, {"kind": "method", "impl": "string", "sig": "pub fn to_text(self, alloc: buffer::Alloc) -> Result<Text, buffer::AllocErr>", "docs": ["Copy this string view into a new owned Text with the provided allocator."]}, {"kind": "method", "impl": "string", "sig": "pub fn concat(self, alloc: buffer::Alloc, other: string) -> Result<string, buffer::AllocErr>", "docs": ["Concatenate another string into a new owned string view."]}, {"kind": "method", "impl": "string", "sig": "pub fn byte_at(self, index: i32) -> u8", "docs": ["Index into the string by byte."]}, {"kind": "method", "impl": "string", "sig": "pub fn as_slice(self) -> Slice<u8>", "docs": ["Borrow the underlying byte slice (no copy)."]}, {"kind": "method", "impl": "string", "sig": "pub fn bytes(self) -> Slice<u8>", "docs": ["bytes() is an alias for as_slice()."]}, {"kind": "method", "impl": "string", "sig": "pub fn split_whitespace(self, alloc: buffer::Alloc) -> Vec<string>", "docs": ["Split on ASCII whitespace."]}, {"kind": "method", "impl": "string", "sig": "pub fn lines(self, alloc: buffer::Alloc) -> Vec<string>", "docs": []}, {"kind": "method", "impl": "string", "sig": "pub fn split(self, alloc: buffer::Alloc, delim: u8) -> Vec<string>", "docs": []}, {"kind": "method", "impl": "string", "sig": "pub fn split_once(self, alloc: buffer::Alloc, delim: u8) -> Result<SplitOnce, unit>", "docs": ["Split once on the first matching delimiter."]}, {"kind": "method", "impl": "string", "sig": "pub fn trim(self, alloc: buffer::Alloc) -> string", "docs": ["Trim ASCII whitespace from both ends."]}, {"kind": "method", "impl": "string", "sig": "pub fn trim_start(self, alloc: buffer::Alloc) -> string", "docs": ["Trim ASCII whitespace from the start."]}, {"kind": "method", "impl": "string", "sig": "pub fn trim_end(self, alloc: buffer::Alloc) -> string", "docs": ["Trim ASCII whitespace from the end."]}, {"kind": "method", "impl": "string", "sig": "pub fn trim_prefix(self, alloc: buffer::Alloc, prefix: string) -> string", "docs": ["Remove a leading prefix if present."]}, {"kind": "method", "impl": "string", "sig": "pub fn trim_suffix(self, alloc: buffer::Alloc, suffix: string) -> string", "docs": ["Remove a trailing suffix if present."]}, {"kind": "method", "impl": "string", "sig": "pub fn split_lines(self, alloc: buffer::Alloc) -> Vec<string>", "docs": ["split_lines() is an alias for lines()."]}, {"kind": "method", "impl": "string", "sig": "pub fn starts_with(self, prefix: string) -> bool", "docs": ["True if the string starts with the prefix."]}, {"kind": "method", "impl": "string", "sig": "pub fn ends_with(self, suffix: string) -> bool", "docs": ["True if the string ends with the suffix."]}, {"kind": "method", "impl": "string", "sig": "pub fn starts_with_byte(self, prefix: u8) -> bool", "docs": ["True if the first byte matches."]}, {"kind": "method", "impl": "string", "sig": "pub fn ends_with_byte(self, suffix: u8) -> bool", "docs": ["True if the last byte matches."]}, {"kind": "method", "impl": "string", "sig": "pub fn eq(self, other: string) -> bool", "docs": ["Byte-wise equality."]}, {"kind": "method", "impl": "string", "sig": "pub fn is_empty(self) -> bool", "docs": ["True if empty."]}, {"kind": "method", "impl": "string", "sig": "pub fn byte_at_checked(self, index: i32) -> Result<u8, unit>", "docs": ["Checked byte access."]}, {"kind": "method", "impl": "string", "sig": "pub fn index_of_byte(self, needle: u8) -> Result<i32, unit>", "docs": ["Find the first matching byte."]}, {"kind": "method", "impl": "string", "sig": "pub fn last_index_of_byte(self, needle: u8) -> Result<i32, unit>", "docs": ["Find the last matching byte."]}, {"kind": "method", "impl": "string", "sig": "pub fn index_of(self, needle: string) -> Result<i32, unit>", "docs": ["Return the index of a substring if present."]}, {"kind": "method", "impl": "string", "sig": "pub fn last_index_of(self, needle: string) -> Result<i32, unit>", "docs": ["Return the last index of a substring if present."]}, {"kind": "method", "impl": "string", "sig": "pub fn contains(self, needle: string) -> bool", "docs": ["True if the substring is present."]}, {"kind": "method", "impl": "string", "sig": "pub fn contains_byte(self, needle: u8) -> bool", "docs": ["True if the byte is present."]}, {"kind": "method", "impl": "string", "sig": "pub fn count_byte(self, needle: u8) -> i32", "docs": ["Count occurrences of a byte."]}, {"kind": "method", "impl": "string", "sig": "pub fn is_ascii(self) -> bool", "docs": ["True if all bytes are ASCII."]}, {"kind": "method", "impl": "string", "sig": "pub fn to_lower_ascii(self, alloc: buffer::Alloc) -> string", "docs": ["Lowercase ASCII letters."]}, {"kind": "method", "impl": "string", "sig": "pub fn to_upper_ascii(self, alloc: buffer::Alloc) -> string", "docs": ["Uppercase ASCII letters."]}, {"kind": "method", "impl": "string", "sig": "pub fn trim_ascii(self, alloc: buffer::Alloc) -> string", "docs": ["Trim ASCII whitespace (alias of trim())."]}, {"kind": "method", "impl": "string", "sig": "pub fn find_byte(self, needle: u8) -> Result<i32, unit>", "docs": ["Alias for index_of_byte."]}, {"kind": "method", "impl": "string", "sig": "pub fn rfind_byte(self, needle: u8) -> Result<i32, unit>", "docs": ["Alias for last_index_of_byte."]}], "source": "/// UTF-8-ish string types.\n/// `string` is a lightweight view backed by a byte slice.\n/// `Text` is an owned, growable UTF-8 buffer backed by Vec<u8>.\npackage safe\nmodule sys::string\n\nuse sys::buffer\nuse sys::bytes\nuse sys::vec\n\n/// String view backed by a byte slice (non-owning).\npub copy struct string {\n  bytes: Slice<u8>\n}\n\n/// Owned UTF-8 text backed by a Vec<u8>.\n/// Text is a growable, heap-backed string builder.\npub struct Text {\n  bytes: vec::Vec<u8>\n}\n\n/// Result payload for split_once.\npub struct SplitOnce {\n  left: string,\n  right: string\n}\n\n/// Wrap a slice as a string view (no copy).\n/// The view is only valid while the slice's backing storage is alive.\npub fn from_bytes(bytes: Slice<u8>) -> Result<string, buffer::AllocErr> {\n  return Ok(string { bytes: bytes })\n}\n\n/// Copy a slice into a new owned string view using the provided allocator.\npub fn from_bytes_copy(alloc: buffer::Alloc, bytes: Slice<u8>) -> Result<string, buffer::AllocErr> {\n  let owned = buffer::copy_slice(alloc, bytes)?\n  return Ok(string { bytes: owned })\n}\n\n/// Allocate a new empty Text using the provided allocator.\npub fn text_new(alloc: buffer::Alloc) -> Text {\n  return Text { bytes: alloc.vec_u8_new() }\n}\n\n/// Allocate a new empty Text with capacity using the provided allocator.\npub fn text_with_capacity(alloc: buffer::Alloc, capacity: i32) -> Result<Text, buffer::AllocErr> {\n  let bytes = alloc.vec_u8_with_capacity(capacity)?\n  return Ok(Text { bytes: bytes })\n}\n\n/// Copy a string view into a new Text using the provided allocator.\npub fn text_from(alloc: buffer::Alloc, s: string) -> Result<Text, buffer::AllocErr> {\n  let out = text_new(alloc)\n  out.push_str(s)?\n  return Ok(out)\n}\n\nfn build_range(alloc: buffer::Alloc, s: string, start: i32, end: i32) -> string {\n  if (end <= start) {\n    return \"\"\n  }\n  let buf = text_new(alloc)\n  let i = start\n  while (i < end) {\n    match (buf.push_byte(s.byte_at(i))) {\n      Ok(_) => { }\n      Err(_) => { panic() }\n    }\n    i = i + 1\n  }\n  match (buf.to_string()) {\n    Ok(out) => { return out }\n    Err(_) => { panic() }\n  }\n}\n\nfn lower_ascii_byte(b: u8) -> u8 {\n  match (b) {\n    'A' => { return 'a' }\n    'B' => { return 'b' }\n    'C' => { return 'c' }\n    'D' => { return 'd' }\n    'E' => { return 'e' }\n    'F' => { return 'f' }\n    'G' => { return 'g' }\n    'H' => { return 'h' }\n    'I' => { return 'i' }\n    'J' => { return 'j' }\n    'K' => { return 'k' }\n    'L' => { return 'l' }\n    'M' => { return 'm' }\n    'N' => { return 'n' }\n    'O' => { return 'o' }\n    'P' => { return 'p' }\n    'Q' => { return 'q' }\n    'R' => { return 'r' }\n    'S' => { return 's' }\n    'T' => { return 't' }\n    'U' => { return 'u' }\n    'V' => { return 'v' }\n    'W' => { return 'w' }\n    'X' => { return 'x' }\n    'Y' => { return 'y' }\n    'Z' => { return 'z' }\n    _ => { return b }\n  }\n}\n\nfn upper_ascii_byte(b: u8) -> u8 {\n  match (b) {\n    'a' => { return 'A' }\n    'b' => { return 'B' }\n    'c' => { return 'C' }\n    'd' => { return 'D' }\n    'e' => { return 'E' }\n    'f' => { return 'F' }\n    'g' => { return 'G' }\n    'h' => { return 'H' }\n    'i' => { return 'I' }\n    'j' => { return 'J' }\n    'k' => { return 'K' }\n    'l' => { return 'L' }\n    'm' => { return 'M' }\n    'n' => { return 'N' }\n    'o' => { return 'O' }\n    'p' => { return 'P' }\n    'q' => { return 'Q' }\n    'r' => { return 'R' }\n    's' => { return 'S' }\n    't' => { return 'T' }\n    'u' => { return 'U' }\n    'v' => { return 'V' }\n    'w' => { return 'W' }\n    'x' => { return 'X' }\n    'y' => { return 'Y' }\n    'z' => { return 'Z' }\n    _ => { return b }\n  }\n}\n\nimpl Text {\n  /// Current length in bytes.\n  pub fn len(self) -> i32 {\n    return self.bytes.len()\n  }\n\n  /// True if empty.\n  pub fn is_empty(self) -> bool {\n    return self.bytes.is_empty()\n  }\n\n  /// Append a single byte.\n  /// Bytes are not validated as UTF-8; use with ASCII or known UTF-8 bytes.\n  pub fn push_byte(self, b: u8) -> Result<unit, buffer::AllocErr> {\n    return self.bytes.push(b)\n  }\n\n  /// Append bytes from a slice.\n  /// Bytes are not validated as UTF-8; use with ASCII or known UTF-8 bytes.\n  pub fn extend_slice(self, data: Slice<u8>) -> Result<unit, buffer::AllocErr> {\n    return self.bytes.extend_slice(data)\n  }\n\n  /// Append bytes from a Vec<u8>.\n  pub fn extend_vec(self, data: vec::Vec<u8>) -> Result<unit, buffer::AllocErr> {\n    return self.extend_slice(data.as_slice())\n  }\n\n  /// Append bytes from a string view.\n  /// This preserves the UTF-8 bytes of the view.\n  pub fn push_str(self, s: string) -> Result<unit, buffer::AllocErr> {\n    return self.extend_slice(s.as_slice())\n  }\n\n  /// Append a string view (alias of push_str).\n  pub fn append(self, s: string) -> Result<unit, buffer::AllocErr> {\n    return self.push_str(s)\n  }\n\n  /// Borrow as a byte slice view (no copy).\n  pub fn as_slice(self) -> Slice<u8> {\n    return self.bytes.as_slice()\n  }\n\n  /// Borrow as a string view (no copy).\n  /// The view is invalid after freeing this Text.\n  pub fn as_string(self) -> string {\n    return string { bytes: self.as_slice() }\n  }\n\n  /// Borrow a subslice of this Text as a string view (byte offsets, end exclusive).\n  /// The view is invalid after freeing this Text.\n  pub fn slice_range(self, start: i32, end: i32) -> Result<string, buffer::SliceErr> {\n    let sub = self.as_slice().slice_range(start, end)?\n    return Ok(string { bytes: sub })\n  }\n\n  /// Copy contents into a new string view.\n  /// This allocates a new owned slice for the string view.\n  pub fn to_string(self) -> Result<string, buffer::AllocErr> {\n    let owned = self.bytes.copy_slice()?\n    return from_bytes(owned)\n  }\n\n  /// Free the underlying Vec<u8>.\n  /// All derived views become invalid after this call.\n  pub fn free(self, alloc: buffer::Alloc) -> unit {\n    alloc.vec_u8_free(self.bytes)\n    return ()\n  }\n\n  /// Remove all bytes from this Text.\n  pub fn clear(self) -> unit {\n    self.bytes.clear()\n    return ()\n  }\n}\n\nimpl string {\n  /// Return the length in bytes.\n  pub fn len(self) -> i32 {\n    return self.bytes.len()\n  }\n\n  /// Create a subslice view of this string by byte offset.\n  /// The view is invalid if the backing storage is freed.\n  pub fn slice(self, start: i32, len: i32) -> Result<string, buffer::SliceErr> {\n    let sub = self.as_slice().slice(start, len)?\n    return Ok(string { bytes: sub })\n  }\n\n  /// Create a subslice view of this string using start/end bounds (end exclusive).\n  /// Offsets are byte indices (no UTF-8 validation).\n  pub fn slice_range(self, start: i32, end: i32) -> Result<string, buffer::SliceErr> {\n    let sub = self.as_slice().slice_range(start, end)?\n    return Ok(string { bytes: sub })\n  }\n\n  /// Copy this string view into a new owned Text with the provided allocator.\n  pub fn to_text(self, alloc: buffer::Alloc) -> Result<Text, buffer::AllocErr> {\n    return text_from(alloc, self)\n  }\n\n  /// Concatenate another string into a new owned string view.\n  pub fn concat(self, alloc: buffer::Alloc, other: string) -> Result<string, buffer::AllocErr> {\n    let out = text_new(alloc)\n    out.push_str(self)?\n    out.push_str(other)?\n    return out.to_string()\n  }\n\n  /// Index into the string by byte.\n  pub fn byte_at(self, index: i32) -> u8 {\n    return self.bytes.at(index)\n  }\n\n  /// Borrow the underlying byte slice (no copy).\n  pub fn as_slice(self) -> Slice<u8> {\n    return self.bytes\n  }\n\n  /// bytes() is an alias for as_slice().\n  pub fn bytes(self) -> Slice<u8> {\n    return self.as_slice()\n  }\n\n  /// Split on ASCII whitespace.\n  pub fn split_whitespace(self, alloc: buffer::Alloc) -> Vec<string> {\n    let out = alloc.vec_string_new()\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let i = 0\n    while (i < len) {\n      while (i < len && bytes.at(i).is_whitespace()) {\n        i = i + 1\n      }\n      if (i >= len) {\n        break\n      }\n      let start = i\n      while (i < len && !bytes.at(i).is_whitespace()) {\n        i = i + 1\n      }\n      let part = build_range(alloc, self, start, i)\n      match (out.push(part)) {\n        Ok(_) => { }\n        Err(_) => { panic() }\n      }\n    }\n    return out\n  }\n\n  pub fn lines(self, alloc: buffer::Alloc) -> Vec<string> {\n    let out = alloc.vec_string_new()\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let start = 0\n    let i = 0\n    while (i < len) {\n      if (bytes.at(i) == '\\n') {\n        let end = i\n        if (end > start && bytes.at(end - 1) == '\\r') {\n          end = end - 1\n        }\n        let part = build_range(alloc, self, start, end)\n        match (out.push(part)) {\n          Ok(_) => { }\n          Err(_) => { panic() }\n        }\n        start = i + 1\n      }\n      i = i + 1\n    }\n    if (start < len) {\n      let end = len\n      if (end > start && bytes.at(end - 1) == '\\r') {\n        end = end - 1\n      }\n      let part = build_range(alloc, self, start, end)\n      match (out.push(part)) {\n        Ok(_) => { }\n        Err(_) => { panic() }\n      }\n    }\n    return out\n  }\n\n  pub fn split(self, alloc: buffer::Alloc, delim: u8) -> Vec<string> {\n    let out = alloc.vec_string_new()\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let start = 0\n    let i = 0\n    while (i < len) {\n      if (bytes.at(i) == delim) {\n        let part = build_range(alloc, self, start, i)\n        match (out.push(part)) {\n          Ok(_) => { }\n          Err(_) => { panic() }\n        }\n        start = i + 1\n      }\n      i = i + 1\n    }\n    let part = build_range(alloc, self, start, len)\n    match (out.push(part)) {\n      Ok(_) => { }\n      Err(_) => { panic() }\n    }\n    return out\n  }\n\n  /// Split once on the first matching delimiter.\n  pub fn split_once(self, alloc: buffer::Alloc, delim: u8) -> Result<SplitOnce, unit> {\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let i = 0\n    while (i < len) {\n      if (bytes.at(i) == delim) {\n        let left = build_range(alloc, self, 0, i)\n        let right = build_range(alloc, self, i + 1, len)\n        return Ok(SplitOnce {\n          left: left,\n          right: right\n        })\n      }\n      i = i + 1\n    }\n    return Err(())\n  }\n\n  /// Trim ASCII whitespace from both ends.\n  pub fn trim(self, alloc: buffer::Alloc) -> string {\n    let start_trimmed = self.trim_start(alloc)\n    return start_trimmed.trim_end(alloc)\n  }\n\n  /// Trim ASCII whitespace from the start.\n  pub fn trim_start(self, alloc: buffer::Alloc) -> string {\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let i = 0\n    while (i < len) {\n      if (!bytes.at(i).is_whitespace()) {\n        break\n      }\n      i = i + 1\n    }\n    if (i == 0) {\n      return self\n    }\n    return build_range(alloc, self, i, len)\n  }\n\n  /// Trim ASCII whitespace from the end.\n  pub fn trim_end(self, alloc: buffer::Alloc) -> string {\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    if (len == 0) {\n      return self\n    }\n    let i = len\n    while (i > 0) {\n      if (!bytes.at(i - 1).is_whitespace()) {\n        break\n      }\n      i = i - 1\n    }\n    if (i == len) {\n      return self\n    }\n    if (i == 0) {\n      return \"\"\n    }\n    return build_range(alloc, self, 0, i)\n  }\n\n  /// Remove a leading prefix if present.\n  pub fn trim_prefix(self, alloc: buffer::Alloc, prefix: string) -> string {\n    if (self.starts_with(prefix)) {\n      return build_range(alloc, self, prefix.len(), self.len())\n    }\n    return self\n  }\n\n  /// Remove a trailing suffix if present.\n  pub fn trim_suffix(self, alloc: buffer::Alloc, suffix: string) -> string {\n    if (self.ends_with(suffix)) {\n      return build_range(alloc, self, 0, self.len() - suffix.len())\n    }\n    return self\n  }\n\n  /// split_lines() is an alias for lines().\n  pub fn split_lines(self, alloc: buffer::Alloc) -> Vec<string> {\n    return self.lines(alloc)\n  }\n\n  /// True if the string starts with the prefix.\n  pub fn starts_with(self, prefix: string) -> bool {\n    let self_len = self.len()\n    let prefix_len = prefix.len()\n    if (prefix_len > self_len) {\n      return false\n    }\n    let i = 0\n    while (i < prefix_len) {\n      if self.byte_at(i) != prefix.byte_at(i) {\n        return false\n      }\n      i = i + 1\n    }\n    return true\n  }\n\n  /// True if the string ends with the suffix.\n  pub fn ends_with(self, suffix: string) -> bool {\n    let self_len = self.len()\n    let suffix_len = suffix.len()\n    if (suffix_len > self_len) {\n      return false\n    }\n    let i = 0\n    while (i < suffix_len) {\n      let idx = self_len - suffix_len + i\n      if self.byte_at(idx) != suffix.byte_at(i) {\n        return false\n      }\n      i = i + 1\n    }\n    return true\n  }\n\n  /// True if the first byte matches.\n  pub fn starts_with_byte(self, prefix: u8) -> bool {\n    if (self.len() == 0) {\n      return false\n    }\n    return self.byte_at(0) == prefix\n  }\n\n  /// True if the last byte matches.\n  pub fn ends_with_byte(self, suffix: u8) -> bool {\n    let len = self.len()\n    if (len == 0) {\n      return false\n    }\n    return self.byte_at(len - 1) == suffix\n  }\n\n  /// Byte-wise equality.\n  pub fn eq(self, other: string) -> bool {\n    let self_len = self.len()\n    let other_len = other.len()\n    if (self_len != other_len) {\n      return false\n    }\n    let i = 0\n    while (i < self_len) {\n      if self.byte_at(i) != other.byte_at(i) {\n        return false\n      }\n      i = i + 1\n    }\n    return true\n  }\n\n  /// True if empty.\n  pub fn is_empty(self) -> bool {\n    return self.len() == 0\n  }\n\n  /// Checked byte access.\n  pub fn byte_at_checked(self, index: i32) -> Result<u8, unit> {\n    if (index < 0) {\n      return Err(())\n    }\n    if (index >= self.len()) {\n      return Err(())\n    }\n    return Ok(self.byte_at(index))\n  }\n\n  /// Find the first matching byte.\n  pub fn index_of_byte(self, needle: u8) -> Result<i32, unit> {\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let i = 0\n    while (i < len) {\n      if (bytes.at(i) == needle) {\n        return Ok(i)\n      }\n      i = i + 1\n    }\n    return Err(())\n  }\n\n  /// Find the last matching byte.\n  pub fn last_index_of_byte(self, needle: u8) -> Result<i32, unit> {\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    if (len == 0) {\n      return Err(())\n    }\n    let i = len - 1\n    while (true) {\n      if (bytes.at(i) == needle) {\n        return Ok(i)\n      }\n      if (i == 0) {\n        break\n      }\n      i = i - 1\n    }\n    return Err(())\n  }\n\n  /// Return the index of a substring if present.\n  pub fn index_of(self, needle: string) -> Result<i32, unit> {\n    let hay = self.as_slice()\n    let hay_len = hay.len()\n    let needle_bytes = needle.as_slice()\n    let needle_len = needle_bytes.len()\n    if (needle_len == 0) {\n      return Ok(0)\n    }\n    if (needle_len > hay_len) {\n      return Err(())\n    }\n    let i = 0\n    while (i <= hay_len - needle_len) {\n      let j = 0\n      while (j < needle_len) {\n        if (hay.at(i + j) != needle_bytes.at(j)) {\n          break\n        }\n        j = j + 1\n      }\n      if (j == needle_len) {\n        return Ok(i)\n      }\n      i = i + 1\n    }\n    return Err(())\n  }\n\n  /// Return the last index of a substring if present.\n  pub fn last_index_of(self, needle: string) -> Result<i32, unit> {\n    let hay = self.as_slice()\n    let hay_len = hay.len()\n    let needle_bytes = needle.as_slice()\n    let needle_len = needle_bytes.len()\n    if (needle_len == 0) {\n      return Ok(hay_len)\n    }\n    if (needle_len > hay_len) {\n      return Err(())\n    }\n    let i = hay_len - needle_len\n    while (true) {\n      let j = 0\n      while (j < needle_len) {\n        if (hay.at(i + j) != needle_bytes.at(j)) {\n          break\n        }\n        j = j + 1\n      }\n      if (j == needle_len) {\n        return Ok(i)\n      }\n      if (i == 0) {\n        break\n      }\n      i = i - 1\n    }\n    return Err(())\n  }\n\n  /// True if the substring is present.\n  pub fn contains(self, needle: string) -> bool {\n    match (self.index_of(needle)) {\n      Ok(_) => { return true }\n      Err(_) => { return false }\n    }\n  }\n\n  /// True if the byte is present.\n  pub fn contains_byte(self, needle: u8) -> bool {\n    match (self.index_of_byte(needle)) {\n      Ok(_) => { return true }\n      Err(_) => { return false }\n    }\n  }\n\n  /// Count occurrences of a byte.\n  pub fn count_byte(self, needle: u8) -> i32 {\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let i = 0\n    let count = 0\n    while (i < len) {\n      if (bytes.at(i) == needle) {\n        count = count + 1\n      }\n      i = i + 1\n    }\n    return count\n  }\n\n  /// True if all bytes are ASCII.\n  pub fn is_ascii(self) -> bool {\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let i = 0\n    while (i < len) {\n      if (bytes.at(i) > '\\x7f') {\n        return false\n      }\n      i = i + 1\n    }\n    return true\n  }\n\n  /// Lowercase ASCII letters.\n  pub fn to_lower_ascii(self, alloc: buffer::Alloc) -> string {\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let buf = text_new(alloc)\n    let i = 0\n    while (i < len) {\n      let b = bytes.at(i)\n      let lower = lower_ascii_byte(b)\n      match (buf.push_byte(lower)) {\n        Ok(_) => { }\n        Err(_) => { panic() }\n      }\n      i = i + 1\n    }\n    match (buf.to_string()) {\n      Ok(out) => { return out }\n      Err(_) => { panic() }\n    }\n  }\n\n  /// Uppercase ASCII letters.\n  pub fn to_upper_ascii(self, alloc: buffer::Alloc) -> string {\n    let bytes = self.as_slice()\n    let len = bytes.len()\n    let buf = text_new(alloc)\n    let i = 0\n    while (i < len) {\n      let b = bytes.at(i)\n      let upper = upper_ascii_byte(b)\n      match (buf.push_byte(upper)) {\n        Ok(_) => { }\n        Err(_) => { panic() }\n      }\n      i = i + 1\n    }\n    match (buf.to_string()) {\n      Ok(out) => { return out }\n      Err(_) => { panic() }\n    }\n  }\n\n  /// Trim ASCII whitespace (alias of trim()).\n  pub fn trim_ascii(self, alloc: buffer::Alloc) -> string {\n    return self.trim(alloc)\n  }\n\n  /// Alias for index_of_byte.\n  pub fn find_byte(self, needle: u8) -> Result<i32, unit> {\n    return self.index_of_byte(needle)\n  }\n\n  /// Alias for last_index_of_byte.\n  pub fn rfind_byte(self, needle: u8) -> Result<i32, unit> {\n    return self.last_index_of_byte(needle)\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/system.cap", "module": "sys::system", "docs": ["Root capability minting."], "items": [{"kind": "struct", "sig": "pub copy capability struct RootCap", "docs": ["Root capability for minting sub-capabilities."]}, {"kind": "method", "impl": "RootCap", "sig": "pub fn mint_console(self) -> console::Console", "docs": ["Mint console access."]}, {"kind": "method", "impl": "RootCap", "sig": "pub fn mint_readfs(self, root: string) -> fs::ReadFS", "docs": ["Mint a read-only filesystem rooted at path."]}, {"kind": "method", "impl": "RootCap", "sig": "pub fn mint_filesystem(self, root: string) -> fs::Filesystem", "docs": ["Mint a filesystem rooted at path."]}, {"kind": "method", "impl": "RootCap", "sig": "pub fn mint_alloc_default(self) -> buffer::Alloc", "docs": ["Mint a default Alloc."]}, {"kind": "method", "impl": "RootCap", "sig": "pub fn mint_args(self) -> args::Args", "docs": ["Mint argument access."]}, {"kind": "method", "impl": "RootCap", "sig": "pub fn mint_stdin(self) -> stdin::Stdin", "docs": ["Mint stdin access."]}, {"kind": "method", "impl": "RootCap", "sig": "pub fn mint_net(self) -> net::Net", "docs": ["Mint network access."]}], "source": "/// Root capability minting.\npackage unsafe\nmodule sys::system\nuse sys::console\nuse sys::fs\nuse sys::args\nuse sys::stdin\nuse sys::buffer\nuse sys::net\n\n/// Root capability for minting sub-capabilities.\npub copy capability struct RootCap\n\nimpl RootCap {\n  /// Mint console access.\n  pub fn mint_console(self) -> console::Console {\n    return ()\n  }\n\n  /// Mint a read-only filesystem rooted at path.\n  pub fn mint_readfs(self, root: string) -> fs::ReadFS {\n    return ()\n  }\n\n  /// Mint a filesystem rooted at path.\n  pub fn mint_filesystem(self, root: string) -> fs::Filesystem {\n    return ()\n  }\n\n  /// Mint a default Alloc.\n  pub fn mint_alloc_default(self) -> buffer::Alloc {\n    return ()\n  }\n\n  /// Mint argument access.\n  pub fn mint_args(self) -> args::Args {\n    return ()\n  }\n\n  /// Mint stdin access.\n  pub fn mint_stdin(self) -> stdin::Stdin {\n    return ()\n  }\n\n  /// Mint network access.\n  pub fn mint_net(self) -> net::Net {\n    return ()\n  }\n}\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/unsafe_ptr.cap", "module": "sys::unsafe_ptr", "docs": ["Unsafe pointer and layout helpers for stdlib internals."], "items": [], "source": "/// Unsafe pointer and layout helpers for stdlib internals.\npackage unsafe\nmodule sys::unsafe_ptr\n\n/// Return the size of T in bytes.\npub extern fn sizeof<T>() -> i32\n\n/// Return the alignment of T in bytes.\npub extern fn alignof<T>() -> i32\n\n/// Add element offset to a pointer.\npub extern fn ptr_add<T>(ptr: *T, offset: i32) -> *T\n\n/// Read a value from a pointer (unchecked).\npub extern fn ptr_read<T>(ptr: *T) -> T\n\n/// Write a value to a pointer (unchecked).\npub extern fn ptr_write<T>(ptr: *T, value: T) -> unit\n\n/// Reinterpret a *u8 as a pointer to T.\npub extern fn ptr_cast<T>(ptr: *u8) -> *T\n\n/// Reinterpret a pointer to T as *u8.\npub extern fn ptr_cast_u8<T>(ptr: *T) -> *u8\n\n/// Return true if the pointer is null.\n/// This does not imply ownership or validity beyond null/non-null.\npub extern fn ptr_is_null<T>(ptr: *T) -> bool\n\n/// Copy `count` elements from `src` to `dst` (no overlap).\n/// Use memmove when regions might overlap.\npub extern fn memcpy<T>(dst: *T, src: *T, count: i32) -> unit\n\n/// Copy `count` elements from `src` to `dst` (overlap-safe).\npub extern fn memmove<T>(dst: *T, src: *T, count: i32) -> unit\n"}, {"path": "/Users/jm/Development/capable/stdlib/sys/vec.cap", "module": "sys::vec", "docs": ["Vec helpers for built-in element types.", "Vec<T> is an owned, heap-backed growable container (not a view).", "Use Slice/MutSlice for non-owning views into byte data."], "items": [{"kind": "struct", "sig": "pub copy opaque struct Vec<T>", "docs": ["Internal Vec header stored on the heap.", "Generic Vec marker type (owned, heap-backed container)."]}, {"kind": "enum", "sig": "pub enum VecErr", "docs": ["Vec errors."]}, {"kind": "fn", "impl": null, "sig": "fn alloc_header<T>(alloc: buffer::Alloc) -> *u8", "docs": ["Index is out of range.", "Vec is empty.", "Allocate a new Vec header."]}, {"kind": "fn", "impl": null, "sig": "fn alloc_elems<T>(alloc: buffer::Alloc, cap: i32) -> *u8", "docs": ["Allocate element storage for the given capacity."]}, {"kind": "fn", "impl": null, "sig": "fn free_elems(alloc: buffer::Alloc, raw: *u8) -> unit", "docs": ["Free element storage."]}, {"kind": "fn", "impl": null, "sig": "fn read_header<T>(v: Vec<T>) -> sys::vec::VecHeader", "docs": ["Read the header value."]}, {"kind": "fn", "impl": null, "sig": "fn write_header<T>(v: Vec<T>, header: sys::vec::VecHeader) -> unit", "docs": ["Write the header value."]}, {"kind": "fn", "impl": null, "sig": "fn elem_ptr<T>(raw: *u8, elem_size: i32, index: i32) -> *T", "docs": ["Cast a raw pointer to a typed pointer at the given element index."]}, {"kind": "fn", "impl": null, "sig": "fn copy_elems<T>(dst_raw: *u8, src_raw: *u8, elem_size: i32, count: i32) -> unit", "docs": ["Copy elements from src to dst."]}, {"kind": "fn", "impl": null, "sig": "fn grow_to<T>(v: Vec<T>, header: sys::vec::VecHeader, new_cap: i32) -> Result<unit, buffer::AllocErr>", "docs": ["Grow to a new capacity."]}, {"kind": "fn", "impl": null, "sig": "fn ensure_capacity<T>(v: Vec<T>, header: sys::vec::VecHeader, needed: i32) -> Result<unit, buffer::AllocErr>", "docs": ["Ensure capacity for a target length."]}, {"kind": "fn", "impl": null, "sig": "pub fn new_with<T>(alloc: buffer::Alloc) -> Vec<T>", "docs": ["Create a new Vec with the provided allocator."]}, {"kind": "fn", "impl": null, "sig": "pub fn with_capacity<T>(alloc: buffer::Alloc, capacity: i32) -> Result<Vec<T>, buffer::AllocErr>", "docs": ["Create a new Vec with capacity using the provided allocator."]}, {"kind": "fn", "impl": null, "sig": "pub fn len(self) -> i32", "docs": ["Length in elements."]}, {"kind": "fn", "impl": null, "sig": "pub fn capacity(self) -> i32", "docs": ["Capacity in elements."]}, {"kind": "fn", "impl": null, "sig": "pub fn is_empty(self) -> bool", "docs": ["True if empty."]}, {"kind": "fn", "impl": null, "sig": "pub fn get(self, i: i32) -> Result<T, VecErr>", "docs": ["Get element at index."]}, {"kind": "fn", "impl": null, "sig": "pub fn first(self) -> Result<T, VecErr>", "docs": ["Get the first element."]}, {"kind": "fn", "impl": null, "sig": "pub fn last(self) -> Result<T, VecErr>", "docs": ["Get the last element."]}, {"kind": "fn", "impl": null, "sig": "pub fn set(self, i: i32, x: T) -> Result<unit, VecErr>", "docs": ["Set element at index."]}, {"kind": "fn", "impl": null, "sig": "pub fn push(self, x: T) -> Result<unit, buffer::AllocErr>", "docs": ["Append one element."]}, {"kind": "fn", "impl": null, "sig": "pub fn extend(self, other: Vec<T>) -> Result<unit, buffer::AllocErr>", "docs": ["Append another Vec."]}, {"kind": "fn", "impl": null, "sig": "pub fn reserve(self, additional: i32) -> Result<unit, buffer::AllocErr>", "docs": ["Reserve additional capacity."]}, {"kind": "fn", "impl": null, "sig": "pub fn shrink_to_fit(self) -> unit", "docs": ["Shrink capacity to fit length."]}, {"kind": "fn", "impl": null, "sig": "pub fn push_all(self, other: Vec<T>) -> Result<unit, buffer::AllocErr>", "docs": ["Append another Vec (alias)."]}, {"kind": "fn", "impl": null, "sig": "pub fn pop(self) -> Result<T, VecErr>", "docs": ["Pop last element."]}, {"kind": "fn", "impl": null, "sig": "pub fn clear(self) -> unit", "docs": ["Remove all elements."]}, {"kind": "fn", "impl": null, "sig": "pub fn contains(self, value: T) -> bool", "docs": ["True if the Vec contains value."]}, {"kind": "fn", "impl": null, "sig": "pub fn count(self, value: T) -> i32", "docs": ["Count occurrences of value."]}, {"kind": "fn", "impl": null, "sig": "pub fn index_of(self, value: T) -> Result<i32, VecErr>", "docs": ["Find the first index of value."]}, {"kind": "fn", "impl": null, "sig": "pub fn last_index_of(self, value: T) -> Result<i32, VecErr>", "docs": ["Find the last index of value."]}, {"kind": "fn", "impl": null, "sig": "pub fn filter(self, value: T) -> Vec<T>", "docs": ["Filter elements equal to value (numeric vecs only)."]}, {"kind": "fn", "impl": null, "sig": "pub fn map_add(self, delta: T) -> Vec<T>", "docs": ["Add delta to each element."]}, {"kind": "fn", "impl": null, "sig": "pub fn free(self) -> unit", "docs": ["Free the backing storage and header."]}, {"kind": "method", "impl": "Vec<u8>", "sig": "pub fn extend_slice(self, data: Slice<u8>) -> Result<unit, buffer::AllocErr>", "docs": ["Append a slice of bytes."]}, {"kind": "method", "impl": "Vec<u8>", "sig": "pub fn slice(self, start: i32, len: i32) -> Result<Slice<u8>, VecErr>", "docs": ["Create a slice view of a range."]}, {"kind": "method", "impl": "Vec<u8>", "sig": "pub fn slice_range(self, start: i32, end: i32) -> Result<Slice<u8>, VecErr>", "docs": ["Create a slice view of a range using start/end bounds (end exclusive)."]}, {"kind": "method", "impl": "Vec<u8>", "sig": "pub fn as_slice(self) -> Slice<u8>", "docs": ["Borrow as a slice."]}, {"kind": "method", "impl": "Vec<u8>", "sig": "pub fn copy_slice(self) -> Result<Slice<u8>, buffer::AllocErr>", "docs": ["Copy contents into a new owned slice using the Vec allocator."]}, {"kind": "method", "impl": "Vec<u8>", "sig": "pub fn to_string(self) -> Result<string, buffer::AllocErr>", "docs": ["Copy contents into a new string view."]}, {"kind": "method", "impl": "Vec<string>", "sig": "pub fn join(self, sep: string) -> Result<string, buffer::AllocErr>", "docs": ["Join elements with a separator."]}], "source": "/// Vec helpers for built-in element types.\n/// Vec<T> is an owned, heap-backed growable container (not a view).\n/// Use Slice/MutSlice for non-owning views into byte data.\npackage safe\nmodule sys::vec\n\nuse sys::buffer\nuse sys::string\nuse sys::unsafe_ptr\n\n/// Internal Vec header stored on the heap.\ncopy struct VecHeader {\n  raw: *u8,\n  len: i32,\n  cap: i32,\n  elem_size: i32,\n  alloc: buffer::Alloc\n}\n\n/// Generic Vec marker type (owned, heap-backed container).\npub copy opaque struct Vec<T> {\n  header: *u8\n}\n\n/// Vec errors.\npub enum VecErr {\n  /// Index is out of range.\n  OutOfRange,\n  /// Vec is empty.\n  Empty\n}\n\n/// Allocate a new Vec header.\nfn alloc_header<T>(alloc: buffer::Alloc) -> *u8 {\n  let bytes = unsafe_ptr::sizeof<sys::vec::VecHeader>()\n  let header = alloc.malloc(bytes)\n  let header_ptr: *sys::vec::VecHeader = unsafe_ptr::ptr_cast<sys::vec::VecHeader>(header)\n  if (unsafe_ptr::ptr_is_null<sys::vec::VecHeader>(header_ptr)) {\n    panic()\n  }\n  return header\n}\n\n/// Allocate element storage for the given capacity.\nfn alloc_elems<T>(alloc: buffer::Alloc, cap: i32) -> *u8 {\n  if (cap <= 0) {\n    return alloc.malloc(0)\n  }\n  let size = unsafe_ptr::sizeof<T>()\n  let bytes = size * cap\n  return alloc.malloc(bytes)\n}\n\n/// Free element storage.\nfn free_elems(alloc: buffer::Alloc, raw: *u8) -> unit {\n  alloc.free(raw)\n  return ()\n}\n\n/// Read the header value.\nfn read_header<T>(v: Vec<T>) -> sys::vec::VecHeader {\n  let header_ptr: *sys::vec::VecHeader = unsafe_ptr::ptr_cast<sys::vec::VecHeader>(v.header)\n  return unsafe_ptr::ptr_read<sys::vec::VecHeader>(header_ptr)\n}\n\n/// Write the header value.\nfn write_header<T>(v: Vec<T>, header: sys::vec::VecHeader) -> unit {\n  let header_ptr: *sys::vec::VecHeader = unsafe_ptr::ptr_cast<sys::vec::VecHeader>(v.header)\n  unsafe_ptr::ptr_write<sys::vec::VecHeader>(header_ptr, header)\n  return ()\n}\n\n/// Cast a raw pointer to a typed pointer at the given element index.\nfn elem_ptr<T>(raw: *u8, elem_size: i32, index: i32) -> *T {\n  let offset = elem_size * index\n  let ptr = unsafe_ptr::ptr_add<u8>(raw, offset)\n  return unsafe_ptr::ptr_cast<T>(ptr)\n}\n\n/// Copy elements from src to dst.\nfn copy_elems<T>(dst_raw: *u8, src_raw: *u8, elem_size: i32, count: i32) -> unit {\n  let i = 0\n  while (i < count) {\n    let value = unsafe_ptr::ptr_read<T>(elem_ptr<T>(src_raw, elem_size, i))\n    unsafe_ptr::ptr_write<T>(elem_ptr<T>(dst_raw, elem_size, i), value)\n    i = i + 1\n  }\n  return ()\n}\n\n/// Grow to a new capacity.\nfn grow_to<T>(v: Vec<T>, header: sys::vec::VecHeader, new_cap: i32) -> Result<unit, buffer::AllocErr> {\n  let new_raw = alloc_elems<T>(header.alloc, new_cap)\n  if (new_cap > 0 && unsafe_ptr::ptr_is_null<u8>(new_raw)) {\n    return Err(buffer::AllocErr::Oom)\n  }\n  copy_elems<T>(new_raw, header.raw, header.elem_size, header.len)\n  free_elems(header.alloc, header.raw)\n  let new_header = sys::vec::VecHeader {\n    raw: new_raw,\n    len: header.len,\n    cap: new_cap,\n    elem_size: header.elem_size,\n    alloc: header.alloc\n  }\n  write_header<T>(v, new_header)\n  return Ok(())\n}\n\n/// Ensure capacity for a target length.\nfn ensure_capacity<T>(v: Vec<T>, header: sys::vec::VecHeader, needed: i32) -> Result<unit, buffer::AllocErr> {\n  if (needed <= header.cap) {\n    return Ok(())\n  }\n  let new_cap = header.cap\n  if (new_cap < 4) {\n    new_cap = 4\n  } else {\n    new_cap = new_cap * 2\n  }\n  while (new_cap < needed) {\n    new_cap = new_cap * 2\n  }\n  return grow_to<T>(v, header, new_cap)\n}\n\n/// Create a new Vec with the provided allocator.\npub fn new_with<T>(alloc: buffer::Alloc) -> Vec<T> {\n  let header_ptr = alloc_header<T>(alloc)\n  let raw = alloc.malloc(0)\n  let header = sys::vec::VecHeader {\n    raw: raw,\n    len: 0,\n    cap: 0,\n    elem_size: unsafe_ptr::sizeof<T>(),\n    alloc: alloc\n  }\n  write_header<T>(Vec<T> { header: header_ptr }, header)\n  return Vec<T> { header: header_ptr }\n}\n\n/// Create a new Vec with capacity using the provided allocator.\npub fn with_capacity<T>(alloc: buffer::Alloc, capacity: i32) -> Result<Vec<T>, buffer::AllocErr> {\n  let cap = capacity\n  if (cap < 0) {\n    cap = 0\n  }\n  let header_ptr = alloc_header<T>(alloc)\n  let raw = alloc_elems<T>(alloc, cap)\n  if (cap > 0 && unsafe_ptr::ptr_is_null<u8>(raw)) {\n    free_elems(alloc, header_ptr)\n    return Err(buffer::AllocErr::Oom)\n  }\n  let header = sys::vec::VecHeader {\n    raw: raw,\n    len: 0,\n    cap: cap,\n    elem_size: unsafe_ptr::sizeof<T>(),\n    alloc: alloc\n  }\n  write_header<T>(Vec<T> { header: header_ptr }, header)\n  return Ok(Vec<T> { header: header_ptr })\n}\n\nimpl<T> Vec<T> {\n  /// Length in elements.\n  pub fn len(self) -> i32 {\n    let header = read_header<T>(self)\n    return header.len\n  }\n\n  /// Capacity in elements.\n  pub fn capacity(self) -> i32 {\n    let header = read_header<T>(self)\n    return header.cap\n  }\n\n  /// True if empty.\n  pub fn is_empty(self) -> bool {\n    return self.len() == 0\n  }\n\n  /// Get element at index.\n  pub fn get(self, i: i32) -> Result<T, VecErr> {\n    let header = read_header<T>(self)\n    if (i < 0 || i >= header.len) {\n      return Err(VecErr::OutOfRange)\n    }\n    let ptr = elem_ptr<T>(header.raw, header.elem_size, i)\n    return Ok(unsafe_ptr::ptr_read<T>(ptr))\n  }\n\n  /// Get the first element.\n  pub fn first(self) -> Result<T, VecErr> {\n    return self.get(0)\n  }\n\n  /// Get the last element.\n  pub fn last(self) -> Result<T, VecErr> {\n    let len = self.len()\n    if (len == 0) {\n      return Err(VecErr::Empty)\n    }\n    return self.get(len - 1)\n  }\n\n  /// Set element at index.\n  pub fn set(self, i: i32, x: T) -> Result<unit, VecErr> {\n    let header = read_header<T>(self)\n    if (i < 0 || i >= header.len) {\n      return Err(VecErr::OutOfRange)\n    }\n    let ptr = elem_ptr<T>(header.raw, header.elem_size, i)\n    unsafe_ptr::ptr_write<T>(ptr, x)\n    return Ok(())\n  }\n\n  /// Append one element.\n  pub fn push(self, x: T) -> Result<unit, buffer::AllocErr> {\n    self.reserve(1)?\n    let header = read_header<T>(self)\n    let ptr = elem_ptr<T>(header.raw, header.elem_size, header.len)\n    unsafe_ptr::ptr_write<T>(ptr, x)\n    let new_header = sys::vec::VecHeader {\n      raw: header.raw,\n      len: header.len + 1,\n      cap: header.cap,\n      elem_size: header.elem_size,\n      alloc: header.alloc\n    }\n    write_header<T>(self, new_header)\n    return Ok(())\n  }\n\n  /// Append another Vec.\n  pub fn extend(self, other: Vec<T>) -> Result<unit, buffer::AllocErr> {\n    let other_header = read_header<T>(other)\n    self.reserve(other_header.len)?\n    let i = 0\n    while (i < other_header.len) {\n      let value = unsafe_ptr::ptr_read<T>(elem_ptr<T>(other_header.raw, other_header.elem_size, i))\n      self.push(value)?\n      i = i + 1\n    }\n    return Ok(())\n  }\n\n  /// Reserve additional capacity.\n  pub fn reserve(self, additional: i32) -> Result<unit, buffer::AllocErr> {\n    if (additional <= 0) {\n      return Ok(())\n    }\n    let header = read_header<T>(self)\n    let needed = header.len + additional\n    return ensure_capacity<T>(self, header, needed)\n  }\n\n  /// Shrink capacity to fit length.\n  pub fn shrink_to_fit(self) -> unit {\n    let header = read_header<T>(self)\n    if (header.len == header.cap) {\n      return ()\n    }\n    if (header.len == 0) {\n      free_elems(header.alloc, header.raw)\n      let raw = header.alloc.malloc(0)\n      let new_header = sys::vec::VecHeader {\n        raw: raw,\n        len: 0,\n        cap: 0,\n        elem_size: header.elem_size,\n        alloc: header.alloc\n      }\n      write_header<T>(self, new_header)\n      return ()\n    }\n    let new_raw = alloc_elems<T>(header.alloc, header.len)\n    if (header.len > 0 && unsafe_ptr::ptr_is_null<u8>(new_raw)) {\n      return ()\n    }\n    copy_elems<T>(new_raw, header.raw, header.elem_size, header.len)\n    free_elems(header.alloc, header.raw)\n    let new_header = sys::vec::VecHeader {\n      raw: new_raw,\n      len: header.len,\n      cap: header.len,\n      elem_size: header.elem_size,\n      alloc: header.alloc\n    }\n    write_header<T>(self, new_header)\n    return ()\n  }\n\n  /// Append another Vec (alias).\n  pub fn push_all(self, other: Vec<T>) -> Result<unit, buffer::AllocErr> {\n    return self.extend(other)\n  }\n\n  /// Pop last element.\n  pub fn pop(self) -> Result<T, VecErr> {\n    let header = read_header<T>(self)\n    if (header.len == 0) {\n      return Err(VecErr::Empty)\n    }\n    let index = header.len - 1\n    let ptr = elem_ptr<T>(header.raw, header.elem_size, index)\n    let value = unsafe_ptr::ptr_read<T>(ptr)\n    let new_header = sys::vec::VecHeader {\n      raw: header.raw,\n      len: index,\n      cap: header.cap,\n      elem_size: header.elem_size,\n      alloc: header.alloc\n    }\n    write_header<T>(self, new_header)\n    return Ok(value)\n  }\n\n  /// Remove all elements.\n  pub fn clear(self) -> unit {\n    while (true) {\n      match (self.pop()) {\n        Ok(_) => { }\n        Err(_) => { break }\n      }\n    }\n    return ()\n  }\n\n  /// True if the Vec contains value.\n  pub fn contains(self, value: T) -> bool {\n    let len = self.len()\n    let i = 0\n    while (i < len) {\n      match (self.get(i)) {\n        Ok(v) => {\n          if (v == value) {\n            return true\n          }\n        }\n        Err(_) => { return false }\n      }\n      i = i + 1\n    }\n    return false\n  }\n\n  /// Count occurrences of value.\n  pub fn count(self, value: T) -> i32 {\n    let len = self.len()\n    let i = 0\n    let out = 0\n    while (i < len) {\n      match (self.get(i)) {\n        Ok(v) => {\n          if (v == value) {\n            out = out + 1\n          }\n        }\n        Err(_) => { return out }\n      }\n      i = i + 1\n    }\n    return out\n  }\n\n  /// Find the first index of value.\n  pub fn index_of(self, value: T) -> Result<i32, VecErr> {\n    let len = self.len()\n    let i = 0\n    while (i < len) {\n      match (self.get(i)) {\n        Ok(v) => {\n          if (v == value) {\n            return Ok(i)\n          }\n        }\n        Err(_) => { return Err(VecErr::OutOfRange) }\n      }\n      i = i + 1\n    }\n    return Err(VecErr::OutOfRange)\n  }\n\n  /// Find the last index of value.\n  pub fn last_index_of(self, value: T) -> Result<i32, VecErr> {\n    let len = self.len()\n    let i = len - 1\n    while (i >= 0) {\n      match (self.get(i)) {\n        Ok(v) => {\n          if (v == value) {\n            return Ok(i)\n          }\n        }\n        Err(_) => { return Err(VecErr::OutOfRange) }\n      }\n      i = i - 1\n    }\n    return Err(VecErr::OutOfRange)\n  }\n\n  /// Filter elements equal to value (numeric vecs only).\n  pub fn filter(self, value: T) -> Vec<T> {\n    let header = read_header<T>(self)\n    let out = new_with<T>(header.alloc)\n    let len = self.len()\n    let i = 0\n    while (i < len) {\n      match (self.get(i)) {\n        Ok(v) => {\n          if (v == value) {\n            match (out.push(v)) {\n              Ok(_) => { }\n              Err(_) => { panic() }\n            }\n          }\n        }\n        Err(_) => { return out }\n      }\n      i = i + 1\n    }\n    return out\n  }\n\n  /// Add delta to each element.\n  pub fn map_add(self, delta: T) -> Vec<T> {\n    let header = read_header<T>(self)\n    let out = new_with<T>(header.alloc)\n    let len = self.len()\n    let i = 0\n    while (i < len) {\n      match (self.get(i)) {\n        Ok(v) => {\n          match (out.push(v + delta)) {\n            Ok(_) => { }\n            Err(_) => { panic() }\n          }\n        }\n        Err(_) => { return out }\n      }\n      i = i + 1\n    }\n    return out\n  }\n\n  /// Free the backing storage and header.\n  pub fn free(self) -> unit {\n    let header = read_header<T>(self)\n    free_elems(header.alloc, header.raw)\n    free_elems(header.alloc, self.header)\n    return ()\n  }\n}\n\nimpl Vec<u8> {\n  /// Append a slice of bytes.\n  pub fn extend_slice(self, data: Slice<u8>) -> Result<unit, buffer::AllocErr> {\n    let len = data.len()\n    let i = 0\n    while (i < len) {\n      self.push(data.at(i))?\n      i = i + 1\n    }\n    return Ok(())\n  }\n\n  /// Create a slice view of a range.\n  pub fn slice(self, start: i32, len: i32) -> Result<Slice<u8>, VecErr> {\n    let header = read_header<u8>(self)\n    if (start < 0 || len < 0) {\n      return Err(VecErr::OutOfRange)\n    }\n    if (start + len > header.len) {\n      return Err(VecErr::OutOfRange)\n    }\n    let ptr = elem_ptr<u8>(header.raw, header.elem_size, start)\n    return Ok(header.alloc.slice_from_ptr(ptr, len))\n  }\n\n  /// Create a slice view of a range using start/end bounds (end exclusive).\n  pub fn slice_range(self, start: i32, end: i32) -> Result<Slice<u8>, VecErr> {\n    if (start < 0 || end < 0) {\n      return Err(VecErr::OutOfRange)\n    }\n    if (start > end) {\n      return Err(VecErr::OutOfRange)\n    }\n    return self.slice(start, end - start)\n  }\n\n  /// Borrow as a slice.\n  pub fn as_slice(self) -> Slice<u8> {\n    let header = read_header<u8>(self)\n    return header.alloc.slice_from_ptr(header.raw, header.len)\n  }\n\n  /// Copy contents into a new owned slice using the Vec allocator.\n  pub fn copy_slice(self) -> Result<Slice<u8>, buffer::AllocErr> {\n    let header = read_header<u8>(self)\n    if (header.len == 0) {\n      let raw = header.alloc.malloc(0)\n      return Ok(header.alloc.slice_from_ptr(raw, 0))\n    }\n    let raw = alloc_elems<u8>(header.alloc, header.len)\n    if (unsafe_ptr::ptr_is_null<u8>(raw)) {\n      return Err(buffer::AllocErr::Oom)\n    }\n    copy_elems<u8>(raw, header.raw, header.elem_size, header.len)\n    return Ok(header.alloc.slice_from_ptr(raw, header.len))\n  }\n\n  /// Copy contents into a new string view.\n  pub fn to_string(self) -> Result<string, buffer::AllocErr> {\n    let owned = self.copy_slice()?\n    return string::from_bytes(owned)\n  }\n}\n\nimpl Vec<string> {\n  /// Join elements with a separator.\n  pub fn join(self, sep: string) -> Result<string, buffer::AllocErr> {\n    let len = self.len()\n    let header = read_header<string>(self)\n    let buf = string::text_new(header.alloc)\n    let i = 0\n    while (i < len) {\n      let part = match (self.get(i)) {\n        Ok(v) => { v }\n        Err(_) => { panic() }\n      }\n      if (i > 0) {\n        buf.push_str(sep)?\n      }\n      buf.push_str(part)?\n      i = i + 1\n    }\n    return buf.to_string()\n  }\n}\n"}];
    const moduleList = document.getElementById('module-list');
    const moduleContent = document.getElementById('module-content');

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function highlightCode(code) {
      const keywords = new Set(['fn', 'let', 'if', 'else', 'while', 'for', 'return', 'match', 'struct', 'enum', 'impl', 'pub', 'use', 'module', 'package', 'defer', 'capability', 'linear', 'copy', 'opaque', 'extern', 'true', 'false', 'in', 'break', 'continue', 'drop', 'unsafe', 'safe']);
      const types = new Set(['i32', 'u8', 'u32', 'i64', 'u64', 'bool', 'unit', 'string', 'Result', 'Ok', 'Err', 'RootCap', 'Console', 'Args', 'Stdin', 'Alloc', 'Buffer', 'Slice', 'MutSlice', 'VecU8', 'VecI32', 'VecString', 'ReadFS', 'Filesystem', 'Dir', 'FileRead', 'Net', 'TcpListener', 'TcpConn']);

      return code.replace(/(\/\/\/.*?$|\/\/.*?$)|("(?:[^"\\]|\\.)*")|(\d+)|([a-zA-Z_][a-zA-Z0-9_]*)/gm, (match, comment, str, num, ident) => {
        if (comment) return `<span class="hl-comment">${escapeHtml(comment)}</span>`;
        if (str) return `<span class="hl-string">${escapeHtml(str)}</span>`;
        if (num) return `<span class="hl-number">${escapeHtml(num)}</span>`;
        if (ident) {
          if (keywords.has(ident)) return `<span class="hl-keyword">${ident}</span>`;
          if (types.has(ident)) return `<span class="hl-type">${ident}</span>`;
          return ident;
        }
        return match;
      });
    }

    function renderModule(mod) {
      const kinds = { struct: 'Structs', enum: 'Enums', fn: 'Functions', method: 'Methods' };
      let html = `
        <div class="module-header">
          <h2>${escapeHtml(mod.module)}</h2>
          <div class="module-path">${escapeHtml(mod.path)}</div>
        </div>
      `;

      if (mod.docs && mod.docs.length) {
        html += `<div class="module-docs">${mod.docs.map(d => `<div>${escapeHtml(d)}</div>`).join('')}</div>`;
      }

      for (const kind of ['struct', 'enum', 'fn', 'method']) {
        const items = mod.items.filter(i => i.kind === kind);
        if (items.length === 0) continue;

        html += `<div class="item-section"><h3>${kinds[kind]}</h3>`;
        for (const item of items) {
          html += `<div class="item">`;
          html += `<div class="item-sig">${escapeHtml(item.sig)}</div>`;
          if (item.impl) {
            html += `<div class="item-impl">impl ${escapeHtml(item.impl)}</div>`;
          }
          if (item.docs && item.docs.length) {
            html += `<div class="item-docs">${item.docs.map(d => escapeHtml(d)).join(' ')}</div>`;
          }
          html += `</div>`;
        }
        html += `</div>`;
      }

      html += `<button class="source-toggle" onclick="toggleSource(this)">Show Source</button>`;
      html += `<div class="source-code" style="display:none"><pre><code>${highlightCode(mod.source)}</code></pre></div>`;

      moduleContent.innerHTML = html;
    }

    window.toggleSource = function(btn) {
      const source = btn.nextElementSibling;
      if (source.style.display === 'none') {
        source.style.display = 'block';
        btn.textContent = 'Hide Source';
      } else {
        source.style.display = 'none';
        btn.textContent = 'Show Source';
      }
    };

    // Build module list
    modules.forEach((mod, i) => {
      const link = document.createElement('div');
      link.className = 'module-link' + (i === 0 ? ' active' : '');
      link.textContent = mod.module;
      link.onclick = () => {
        document.querySelectorAll('.module-link').forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        renderModule(mod);
      };
      moduleList.appendChild(link);
    });

    // Load first module
    if (modules.length > 0) {
      renderModule(modules[0]);
    }

    // Interactive dot grid animation
    (function() {
      const canvas = document.getElementById('dot-grid');
      const ctx = canvas.getContext('2d');

      let width, height;
      let dots = [];
      let mouse = { x: -1000, y: -1000 };
      const SPACING = 28;
      const DOT_RADIUS = 1;
      const INFLUENCE_RADIUS = 150;
      const BASE_COLOR = [186, 204, 212];
      const HOVER_COLOR = [245, 124, 108];

      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        initDots();
      }

      function initDots() {
        dots = [];
        const offsetX = (width % SPACING) / 2;
        const offsetY = (height % SPACING) / 2;
        for (let x = offsetX; x < width; x += SPACING) {
          for (let y = offsetY; y < height; y += SPACING) {
            dots.push({ x: x, y: y });
          }
        }
      }

      function animate() {
        ctx.clearRect(0, 0, width, height);

        for (const dot of dots) {
          const dx = mouse.x - dot.x;
          const dy = mouse.y - dot.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          let color, alpha;

          if (dist < INFLUENCE_RADIUS) {
            const t = 1 - dist / INFLUENCE_RADIUS;
            // Blend between base and hover color
            color = [
              BASE_COLOR[0] + (HOVER_COLOR[0] - BASE_COLOR[0]) * t * 0.65,
              BASE_COLOR[1] + (HOVER_COLOR[1] - BASE_COLOR[1]) * t * 0.65,
              BASE_COLOR[2] + (HOVER_COLOR[2] - BASE_COLOR[2]) * t * 0.65
            ];
            alpha = 0.1 + t * 0.25;
          } else {
            color = BASE_COLOR;
            alpha = 0.1;
          }

          ctx.beginPath();
          ctx.arc(dot.x, dot.y, DOT_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
          ctx.fill();
        }

        requestAnimationFrame(animate);
      }

      canvas.style.pointerEvents = 'none';
      window.addEventListener('resize', resize);
      window.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });
      window.addEventListener('mouseleave', () => {
        mouse.x = -1000;
        mouse.y = -1000;
      });

      resize();
      animate();
    })();
  </script>
</body>
</html>
