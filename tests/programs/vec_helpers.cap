package safe
module vec_helpers
use sys::system

pub fn main(rc: RootCap) -> i32 {
  let c = rc.mint_console()
  let alloc = rc.mint_alloc_default()
  let v = alloc.vec_u8_new()
  let with_cap = alloc.vec_with_capacity<u8>(8)
  let extra = alloc.vec_u8_new()
  match (with_cap) {
    Ok(vc) => {
      c.assert(vc.capacity() >= 8)
      vc.clear()
      alloc.vec_u8_free(vc)
    }
    Err(_) => { c.println("vec bad"); return 1 }
  }
  match v.push('A') {
    Ok(x) => {}
    Err(e) => { c.println("vec bad"); return 1 }
  }
  match v.push('B') {
    Ok(x) => {}
    Err(e) => { c.println("vec bad"); return 1 }
  }
  match extra.push('C') {
    Ok(x) => {}
    Err(e) => { c.println("vec bad"); return 1 }
  }
  match v.extend(extra) {
    Ok(x) => {}
    Err(e) => { c.println("vec bad"); return 1 }
  }
  match v.reserve(4) {
    Ok(_) => { c.assert(v.capacity() >= 3) }
    Err(_) => { c.println("vec bad"); return 1 }
  }
  let len = v.len()
  let b = v.get(1)
  let filtered = v.filter('B')
  let mapped = v.map_add('\x01')
  let slice = v.slice_range(1, 3)
  match (b) {
    Ok(x) => {
      c.assert(len == 3 && x == 'B')
      c.assert(filtered.len() == 1)
      match (mapped.get(0)) {
        Ok(v0) => { c.assert(v0 == 'B') }
        Err(e) => { c.println("vec bad"); return 1 }
      }
      match (slice) {
        Ok(s) => { c.assert(s.len() == 2) }
        Err(e) => { c.println("vec bad"); return 1 }
      }
      c.println("vec ok")
      alloc.vec_u8_free(filtered)
      alloc.vec_u8_free(mapped)
      alloc.vec_u8_free(v)
      alloc.vec_u8_free(extra)
      return 0
    }
    Err(e) => {}
  }
  c.println("vec bad")
  alloc.vec_u8_free(v)
  alloc.vec_u8_free(extra)
  return 1
}
