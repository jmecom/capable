package safe
module vec_search_helpers
use sys::system

pub fn main(rc: RootCap) -> i32 {
  let c = rc.mint_console()
  let alloc = rc.mint_alloc_default()
  let v = alloc.vec_i32_new()
  match (v.push(1)) {
    Ok(_) => { }
    Err(_) => { c.assert(false); return 1 }
  }
  match (v.push(2)) {
    Ok(_) => { }
    Err(_) => { c.assert(false); return 1 }
  }
  match (v.push(1)) {
    Ok(_) => { }
    Err(_) => { c.assert(false); return 1 }
  }
  c.assert(v.contains(2))
  c.assert(!v.contains(3))
  c.assert(v.count(1) == 2)
  match (v.index_of(1)) {
    Ok(i) => { c.assert(i == 0) }
    Err(_) => { c.assert(false); return 1 }
  }
  match (v.last_index_of(1)) {
    Ok(i) => { c.assert(i == 2) }
    Err(_) => { c.assert(false); return 1 }
  }
  match (v.first()) {
    Ok(x) => { c.assert(x == 1) }
    Err(_) => { c.assert(false); return 1 }
  }
  match (v.last()) {
    Ok(x) => { c.assert(x == 1) }
    Err(_) => { c.assert(false); return 1 }
  }
  let bytes = alloc.vec_u8_new()
  match (bytes.push('h')) {
    Ok(_) => { }
    Err(_) => { c.assert(false); alloc.vec_i32_free(v); alloc.vec_u8_free(bytes); return 1 }
  }
  match (bytes.push('i')) {
    Ok(_) => { }
    Err(_) => { c.assert(false); alloc.vec_i32_free(v); alloc.vec_u8_free(bytes); return 1 }
  }
  match (bytes.to_string()) {
    Ok(s) => { c.assert(s.eq("hi")) }
    Err(_) => { c.assert(false); alloc.vec_i32_free(v); alloc.vec_u8_free(bytes); return 1 }
  }
  alloc.vec_i32_free(v)
  alloc.vec_u8_free(bytes)
  c.println("vec search ok")
  return 0
}
