package safe
module sort
use sys::system
use sys::console
use sys::stdin
use sys::io
use sys::string
use sys::vec

fn min_i32(a: i32, b: i32) -> i32 {
  if (a < b) {
    return a
  }
  return b
}

// Returns true if a < b lexicographically
fn str_lt(a: string, b: string) -> bool {
  let a_bytes = a.as_slice()
  let b_bytes = b.as_slice()
  let len = min_i32(a_bytes.len(), b_bytes.len())
  let i = 0
  while (i < len) {
    let ca = a_bytes.at(i)
    let cb = b_bytes.at(i)
    if (ca < cb) {
      return true
    }
    if (ca > cb) {
      return false
    }
    i = i + 1
  }
  return a.len() < b.len()
}

// Compare lines at indices i and j
fn line_lt(lines: Vec<string>, i: i32, j: i32) -> bool {
  let line_i = lines[i].unwrap_or("")
  let line_j = lines[j].unwrap_or("")
  return str_lt(line_i, line_j)
}

// Insertion sort on indices
fn sort_indices(lines: Vec<string>, indices: Vec<i32>) -> unit {
  let n = indices.len()
  for i in 1..n {
    let j = i
    while (j > 0) {
      let curr_idx = indices[j].unwrap_or(0)
      let prev_idx = indices[j - 1].unwrap_or(0)
      if (line_lt(lines, curr_idx, prev_idx)) {
        // swap indices[j] and indices[j-1]
        match (indices.set(j, prev_idx)) {
          Ok(ok) => {}
          Err(e) => {}
        }
        match (indices.set(j - 1, curr_idx)) {
          Ok(ok) => {}
          Err(e) => {}
        }
        j = j - 1
      } else {
        break
      }
    }
  }
}

fn run(c: Console, alloc: Alloc, input: Stdin) -> Result<unit, io::IoErr> {
  let contents = input.read_to_string(alloc)?
  let lines = contents.lines(alloc)
  let n = lines.len()

  // Create index array [0, 1, 2, ...]
  let indices = alloc.vec_i32_new()
  for i in 0..n {
    match (indices.push(i)) {
      Ok(ok) => {}
      Err(e) => {}
    }
  }

  sort_indices(lines, indices)

  // Print lines in sorted order (skip empty lines)
  for i in 0..n {
    let idx = indices[i].unwrap_or(0)
    let line = lines[idx].unwrap_or("")
    if (line.len() > 0) {
      c.println(line)
    }
  }

  alloc.vec_i32_free(indices)
  alloc.vec_string_free(lines)
  return Ok(())
}

pub fn main(rc: RootCap) -> i32 {
  let c = rc.mint_console()
  let input = rc.mint_stdin()
  let alloc = rc.mint_alloc_default()
  let result = run(c, alloc, input)
  if (result.is_err()) {
    c.println("error reading input")
    return 1
  }
  return 0
}
