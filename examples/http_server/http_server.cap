// WIP! This is a sample serving to improve the language.

package safe
module http_server
use sys::console
use sys::fs
use sys::net
use sys::args
use sys::system

fn arg_or_default(args: Args, index: i32, default: string) -> string {
  if (args.len() <= index) {
    return default
  }
  match (args.at(index)) {
    Ok(value) => { return value }
    Err(_) => { return default }
  }
}

fn strip_query(raw_path: string) -> string {
  match (raw_path.split(63u8).get(0)) {
    Ok(path) => { return path }
    Err(_) => { return "" }
  }
}

fn sanitize_segment(parts: VecString, i: i32, acc: string, seg: string) -> Result[string, unit] {
  if (seg.len() == 0) {
    return sanitize_parts(parts, i + 1, acc)
  }
  if (seg.eq(".")) {
    return sanitize_parts(parts, i + 1, acc)
  }
  if (seg.eq("..")) {
    return Err(())
  }
  if (acc.len() == 0) {
    return sanitize_parts(parts, i + 1, seg)
  }
  return sanitize_parts(parts, i + 1, fs::join(acc, seg))
}

fn sanitize_parts(parts: VecString, i: i32, acc: string) -> Result[string, unit] {
  if (i >= parts.len()) {
    return Ok(acc)
  }
  match (parts.get(i)) {
    Ok(seg) => { return sanitize_segment(parts, i, acc, seg) }
    Err(_) => { return Err(()) }
  }
}

fn sanitize_path(raw_path: string) -> Result[string, unit] {
  match (sanitize_parts(raw_path.split(47u8), 0, "")) {
    Ok(path) => {
      if (path.len() == 0) {
        return Ok("index.html")
      }
      return Ok(path)
    }
    Err(_) => { return Err(()) }
  }
}

fn parse_request_line(line: string) -> Result[string, unit] {
  let parts = line.trim().split(32u8)
  match (parts.get(0)) {
    Ok(method) => {
      if (!method.eq("GET")) {
        return Err(())
      }
    }
    Err(_) => { return Err(()) }
  }
  match (parts.get(1)) {
    Ok(raw_path) => { return sanitize_path(strip_query(raw_path)) }
    Err(_) => { return Err(()) }
  }
}

fn parse_request_path(req: string) -> Result[string, unit] {
  match (req.lines().get(0)) {
    Ok(line) => { return parse_request_line(line) }
    Err(_) => { return Err(()) }
  }
}

fn respond_ok(conn: &TcpConn, body: string) -> Result[unit, NetErr] {
  conn.write("HTTP/1.0 200 OK\r\nContent-Type: text/plain\r\n\r\n")?
  conn.write(body)?
  return Ok(())
}

fn respond_not_found(conn: &TcpConn) -> Result[unit, NetErr] {
  return conn.write("HTTP/1.0 404 Not Found\r\nContent-Type: text/plain\r\n\r\nnot found\n")
}

fn respond_bad_request(conn: &TcpConn) -> Result[unit, NetErr] {
  return conn.write("HTTP/1.0 400 Bad Request\r\nContent-Type: text/plain\r\n\r\nbad request\n")
}

fn handle_request(conn: &TcpConn, readfs: ReadFS, path: string) -> Result[unit, NetErr] {
  match (readfs.read_to_string(path)) {
    Ok(body) => { return respond_ok(conn, body) }
    Err(_) => { return respond_not_found(conn) }
  }
}

fn serve_once(c: Console, net: Net, readfs: ReadFS) -> Result[unit, NetErr] {
  let listener = net.listen("127.0.0.1", 8080)?
  let conn = listener.accept()?
  let req = conn.read(4096)?
  match (parse_request_path(req)) {
    Ok(path) => { handle_request(conn, readfs, path)? }
    Err(_) => { respond_bad_request(conn)? }
  }
  conn.close()
  return Ok(())
}

pub fn main(rc: RootCap) -> i32 {
  let c = rc.mint_console()
  let net = rc.mint_net()
  let args = rc.mint_args()
  let root = arg_or_default(args, 1, ".")
  let readfs = rc.mint_readfs(root)
  c.println("listening on 127.0.0.1:8080")
  match (serve_once(c, net, readfs)) {
    Ok(_) => {}
    Err(_) => { c.println("server error") }
  }
  return 0
}
