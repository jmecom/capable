// WIP! This is a sample serving to improve the language.

package safe
module http_server
use sys::console
use sys::fs
use sys::net
use sys::args
use sys::system

fn arg_or_default(args: Args, index: i32, default: string) -> string {
  if (args.len() <= index) {
    return default
  }
  return args.at(index).unwrap_or(default)
}

fn strip_query(raw_path: string, alloc: Alloc) -> string {
  match (raw_path.index_of_byte('?')) {
    Ok(i) => {
      match (raw_path.slice_range(0, i)) {
        Ok(view) => { return view }
        Err(_) => { return raw_path }
      }
    }
    Err(_) => { return raw_path }
  }
}

fn sanitize_segment(parts: Vec<string>, i: i32, acc: string, seg: string, alloc: Alloc) -> Result<string, unit> {
  if (seg.len() == 0) {
    return sanitize_parts(parts, i + 1, acc, alloc)
  }
  if (seg == ".") {
    return sanitize_parts(parts, i + 1, acc, alloc)
  }
  if (seg == "..") {
    return Err(())
  }
  if (acc.len() == 0) {
    return sanitize_parts(parts, i + 1, seg, alloc)
  }
  return sanitize_parts(parts, i + 1, fs::join(alloc, acc, seg), alloc)
}

fn sanitize_parts(parts: Vec<string>, i: i32, acc: string, alloc: Alloc) -> Result<string, unit> {
  if (i >= parts.len()) {
    return Ok(acc)
  }
  let seg_result = parts[i]
  match (seg_result) {
    Ok(seg) => { return sanitize_segment(parts, i, acc, seg, alloc) }
    Err(_) => { return Err(()) }
  }
}

fn sanitize_path(raw_path: string, alloc: Alloc) -> Result<string, unit> {
  let parts = raw_path.split(alloc, '/')
  let result = sanitize_parts(parts, 0, "", alloc)
  alloc.vec_string_free(parts)
  match (result) {
    Ok(path) => {
      if (path.len() == 0) {
        return Ok("index.html")
      }
      return Ok(path)
    }
    Err(_) => { return Err(()) }
  }
}

enum ParseErr {
  MissingSpace,
  BadMethod,
  BadSlice
}

fn index_or_space(s: string) -> Result<i32, ParseErr> {
  match (s.index_of_byte(' ')) {
    Ok(i) => { return Ok(i) }
    Err(_) => { return Err(ParseErr::MissingSpace) }
  }
}

fn slice_or_err(s: string, start: i32, end: i32) -> Result<string, ParseErr> {
  match (s.slice_range(start, end)) {
    Ok(v) => { return Ok(v) }
    Err(_) => { return Err(ParseErr::BadSlice) }
  }
}

fn parse_request_line(line: string, alloc: Alloc) -> Result<string, ParseErr> {
  let trimmed = line.trim(alloc)
  let space0 = index_or_space(trimmed)?
  let method = slice_or_err(trimmed, 0, space0)?
  if (method != "GET") {
    return Err(ParseErr::BadMethod)
  }
  let rest = slice_or_err(trimmed, space0 + 1, trimmed.len())?
  let space1 = index_or_space(rest)?
  let path = slice_or_err(rest, 0, space1)?
  match (sanitize_path(strip_query(path, alloc), alloc)) {
    Ok(p) => { return Ok(p) }
    Err(_) => { return Err(ParseErr::BadSlice) }
  }
}

fn parse_request_path(req: string, alloc: Alloc) -> Result<string, ParseErr> {
  let lines = req.lines(alloc)
  let line_result = lines[0]
  alloc.vec_string_free(lines)
  match (line_result) {
    Ok(line) => { return parse_request_line(line, alloc) }
    Err(_) => { return Err(ParseErr::BadSlice) }
  }
}

fn respond_ok(conn: &TcpConn, body: string) -> Result<unit, NetErr> {
  conn.write("HTTP/1.0 200 OK\r\nContent-Type: text/plain\r\n\r\n")?
  conn.write(body)?
  return Ok(())
}

fn respond_not_found(conn: &TcpConn) -> Result<unit, NetErr> {
  return conn.write("HTTP/1.0 404 Not Found\r\nContent-Type: text/plain\r\n\r\nnot found\n")
}

fn respond_bad_request(conn: &TcpConn) -> Result<unit, NetErr> {
  return conn.write("HTTP/1.0 400 Bad Request\r\nContent-Type: text/plain\r\n\r\nbad request\n")
}

fn handle_request(conn: &TcpConn, readfs: ReadFS, alloc: Alloc, req: string) -> Result<unit, NetErr> {
  match (parse_request_path(req, alloc)) {
    Ok(path) => {
      match (readfs.read_to_string(alloc, path)) {
        Ok(body) => { return respond_ok(conn, body) }
        Err(_) => { return respond_not_found(conn) }
      }
    }
    Err(_) => { return respond_bad_request(conn) }
  }
}

fn serve_forever(c: Console, net: Net, rc: RootCap, alloc: Alloc, root: string, port: i32) -> Result<unit, NetErr> {
  let listener = net.listen("127.0.0.1", port)?
  c.println("listening on 127.0.0.1")
  c.print("port: ")
  c.println_i32(port)
  defer listener.close()
  while (true) {
    if let Ok(conn) = listener.accept() {
      let req_result = conn.read(alloc, 4096)
      if (req_result.is_err()) {
        conn.close()
      } else {
        let req = req_result.ok()
        let readfs = rc.mint_readfs(root)
        let handled = handle_request(conn, readfs, alloc, req)
        conn.close()
        if (handled.is_err()) {
          // Ignore per-request write errors; keep the server alive.
        }
      }
    } else {
      continue
    }
    defer c.println("request complete")
  }
  return Ok(())
}

pub fn main(rc: RootCap) -> i32 {
  let c = rc.mint_console()
  let net = rc.mint_net()
  let args = rc.mint_args()
  let alloc = rc.mint_alloc_default()
  let root = arg_or_default(args, 1, "examples/http_server")
  let port = 8090
  let result = serve_forever(c, net, rc, alloc, root, port)
  if (result.is_err()) {
    c.println("server error (is the port in use?)")
  }
  return 0
}
