/// Hash-map demonstration using the Hash trait.
/// This implements a hash-map with i32 keys and i32 values using open addressing.
///
/// DEMONSTRATES:
/// - Trait definition and implementation
/// - Trait bounds on generic functions
/// - Using traits for polymorphic hashing
/// - Vec<CustomStruct> with custom Entry type
/// - Proper tombstone handling and rehashing
///
/// The hash-map uses open addressing with linear probing.
package safe
module hashmap_demo
use sys::console
use sys::buffer
use sys::vec

/// Trait for types that can be hashed.
/// The hash value should be stable: equal values produce equal hashes.
trait Hash {
  fn hash(self) -> i32;
}

/// Trait for types that support equality comparison.
trait Eq {
  fn eq(self, other: Self) -> bool;
}

/// Hash implementation for i32.
/// Uses bit mixing to avoid INT_MIN overflow issues.
impl Hash for i32 {
  fn hash(self) -> i32 {
    // Handle INT_MIN specially to avoid overflow on negation
    // INT_MIN = -2147483648, and 0 - INT_MIN overflows
    let k = self
    if (k == 0 - 2147483647 - 1) {
      // INT_MIN: use a fixed hash value
      return 2147483647
    }
    if (k < 0) {
      k = 0 - k
    }
    // Multiplicative hash with overflow-safe mixing
    // Use XOR to mix bits without risking sign issues
    let h = k ^ (k / 16)
    h = h * 31
    h = h ^ (k / 256)
    h = h * 127
    // Ensure non-negative by masking off sign bit
    h = h & 2147483647
    return h
  }
}

/// Eq implementation for i32.
impl Eq for i32 {
  fn eq(self, other: i32) -> bool {
    return self == other
  }
}

/// Compute a % b using integer division.
fn mod_i32(a: i32, b: i32) -> i32 {
  if (b == 0) {
    panic()
  }
  let quotient = a / b
  return a - quotient * b
}

/// Entry states
copy struct EntryState {
  /// 0=Empty, 1=Occupied, 2=Deleted
  value: i32
}

fn empty_state() -> EntryState {
  return EntryState { value: 0 }
}

fn occupied_state() -> EntryState {
  return EntryState { value: 1 }
}

fn deleted_state() -> EntryState {
  return EntryState { value: 2 }
}

fn is_empty(s: EntryState) -> bool {
  return s.value == 0
}

fn is_occupied(s: EntryState) -> bool {
  return s.value == 1
}

fn is_deleted(s: EntryState) -> bool {
  return s.value == 2
}

/// A hash-map entry containing state, key, and value.
copy struct Entry {
  state: EntryState,
  key: i32,
  value: i32
}

/// Create an empty entry.
fn empty_entry() -> Entry {
  return Entry { state: empty_state(), key: 0, value: 0 }
}

/// A hash-map with i32 keys and i32 values.
/// Like Vec, this is copy (for borrow-lite) but semantically owned.
/// Call hashmap_free() exactly once when done.
copy struct HashMap {
  /// All entries in a single vector
  entries: Vec<Entry>,
  /// Current size (number of occupied entries)
  size: i32,
  /// Number of deleted (tombstone) entries
  deleted: i32,
  /// Capacity
  capacity: i32,
  alloc: buffer::Alloc
}

/// Generic hash function using the Hash trait.
fn compute_hash<K: Hash>(key: K) -> i32 {
  return key.hash()
}

/// Create a new empty hash-map with initial capacity.
pub fn hashmap_new(alloc: buffer::Alloc, initial_capacity: i32) -> HashMap {
  let cap = initial_capacity
  if (cap < 8) {
    cap = 8
  }

  let entries = alloc.vec_new<Entry>()

  // Initialize all entries as empty
  for i in 0..cap {
    match (entries.push(empty_entry())) {
      Ok(_) => {}
      Err(_) => { panic() }
    }
  }

  return HashMap {
    entries: entries,
    size: 0,
    deleted: 0,
    capacity: cap,
    alloc: alloc
  }
}

impl HashMap {
  /// Get the current size of the hash-map.
  pub fn size(self) -> i32 {
    return self.size
  }

  /// Get the capacity of the hash-map.
  pub fn capacity(self) -> i32 {
    return self.capacity
  }

  /// Get the number of used slots (occupied + deleted).
  pub fn used(self) -> i32 {
    return self.size + self.deleted
  }

  /// Check if the map contains a key.
  pub fn contains(self, key: i32) -> bool {
    let cap = self.capacity
    let hash = compute_hash<i32>(key)
    let index = mod_i32(hash, cap)
    let start = index

    for {
      match (self.entries.get(index)) {
        Ok(entry) => {
          if (is_empty(entry.state)) {
            return false
          }
          if (is_occupied(entry.state) && entry.key == key) {
            return true
          }
        }
        Err(_) => { return false }
      }
      index = mod_i32(index + 1, cap)
      if (index == start) {
        return false
      }
    }
    return false
  }

  /// Get a value by key.
  pub fn get(self, key: i32) -> Result<i32, unit> {
    let cap = self.capacity
    let hash = compute_hash<i32>(key)
    let index = mod_i32(hash, cap)
    let start = index

    for {
      match (self.entries.get(index)) {
        Ok(entry) => {
          if (is_empty(entry.state)) {
            return Err(())
          }
          if (is_occupied(entry.state) && entry.key == key) {
            return Ok(entry.value)
          }
        }
        Err(_) => { return Err(()) }
      }
      index = mod_i32(index + 1, cap)
      if (index == start) {
        return Err(())
      }
    }
    return Err(())
  }
}

/// Rehash the map into a new table with the given capacity.
/// Only reinserts occupied entries, clearing all tombstones.
fn hashmap_rehash(map: HashMap, new_cap: i32) -> HashMap {
  let old_entries = map.entries
  let old_cap = map.capacity
  let alloc = map.alloc

  // Create new entries vector
  let new_entries = alloc.vec_new<Entry>()
  for i in 0..new_cap {
    match (new_entries.push(empty_entry())) {
      Ok(_) => {}
      Err(_) => { panic() }
    }
  }

  let new_size = 0

  // Reinsert all occupied entries
  for i in 0..old_cap {
    match (old_entries.get(i)) {
      Ok(entry) => {
        if (is_occupied(entry.state)) {
          // Find slot in new table
          let hash = compute_hash<i32>(entry.key)
          let index = mod_i32(hash, new_cap)

          for {
            match (new_entries.get(index)) {
              Ok(slot) => {
                if (is_empty(slot.state)) {
                  // Found empty slot, insert here
                  let new_entry = Entry { state: occupied_state(), key: entry.key, value: entry.value }
                  match (new_entries.set(index, new_entry)) {
                    Ok(_) => {}
                    Err(_) => { panic() }
                  }
                  new_size = new_size + 1
                  break
                }
                index = mod_i32(index + 1, new_cap)
              }
              Err(_) => { panic() }
            }
          }
        }
      }
      Err(_) => { panic() }
    }
  }

  // Free old entries
  old_entries.free()

  return HashMap {
    entries: new_entries,
    size: new_size,
    deleted: 0,
    capacity: new_cap,
    alloc: alloc
  }
}

/// Insert or update a key-value pair.
/// Automatically rehashes if load factor is too high.
pub fn hashmap_insert(map: HashMap, key: i32, value: i32) -> Result<HashMap, unit> {
  let init_cap = map.capacity
  let used = map.size + map.deleted

  // Check load factor: rehash if used slots > 70% of capacity
  // This accounts for both occupied entries AND tombstones
  let m = map
  if (used * 10 >= init_cap * 7) {
    // Grow to 2x capacity and rehash (clears tombstones)
    m = hashmap_rehash(m, init_cap * 2)
  } else if (m.deleted * 4 > init_cap) {
    // Too many tombstones (>25% of capacity), rehash at same size
    m = hashmap_rehash(m, init_cap)
  }

  let cap = m.capacity

  // Use the Hash trait to compute the hash
  let hash = compute_hash<i32>(key)
  let index = mod_i32(hash, cap)
  let start = index
  let first_available = 0 - 1
  let reusing_tombstone = false

  for {
    match (m.entries.get(index)) {
      Ok(entry) => {
        if (is_empty(entry.state)) {
          // Empty slot found
          if (first_available < 0) {
            first_available = index
          }
          break
        }

        if (is_deleted(entry.state)) {
          // Deleted slot - remember it but keep looking for the key
          if (first_available < 0) {
            first_available = index
            reusing_tombstone = true
          }
        }

        if (is_occupied(entry.state)) {
          // Occupied - check if it's the same key (update case)
          if (entry.key == key) {
            // Update existing entry
            let new_entry = Entry { state: occupied_state(), key: key, value: value }
            match (m.entries.set(index, new_entry)) {
              Ok(_) => {}
              Err(_) => { return Err(()) }
            }
            return Ok(m)
          }
        }

        index = mod_i32(index + 1, cap)
        if (index == start) {
          // Wrapped around
          break
        }
      }
      Err(_) => { return Err(()) }
    }
  }

  if (first_available < 0) {
    return Err(())
  }

  // Insert at first available slot
  let new_entry = Entry { state: occupied_state(), key: key, value: value }
  match (m.entries.set(first_available, new_entry)) {
    Ok(_) => {}
    Err(_) => { return Err(()) }
  }

  // Update counts: if we reused a tombstone, decrement deleted count
  let new_deleted = m.deleted
  if (reusing_tombstone) {
    new_deleted = new_deleted - 1
  }

  return Ok(HashMap {
    entries: m.entries,
    size: m.size + 1,
    deleted: new_deleted,
    capacity: cap,
    alloc: m.alloc
  })
}

/// Remove a key from the hash-map.
pub fn hashmap_remove(map: HashMap, key: i32) -> Result<HashMap, unit> {
  let cap = map.capacity
  let hash = compute_hash<i32>(key)
  let index = mod_i32(hash, cap)
  let start = index

  for {
    match (map.entries.get(index)) {
      Ok(entry) => {
        if (is_empty(entry.state)) {
          // Empty - key not found
          return Err(())
        }

        if (is_occupied(entry.state)) {
          // Occupied - check if it's our key
          if (entry.key == key) {
            // Mark as deleted
            let deleted_entry = Entry { state: deleted_state(), key: entry.key, value: entry.value }
            match (map.entries.set(index, deleted_entry)) {
              Ok(_) => {}
              Err(_) => { return Err(()) }
            }
            return Ok(HashMap {
              entries: map.entries,
              size: map.size - 1,
              deleted: map.deleted + 1,
              capacity: cap,
              alloc: map.alloc
            })
          }
        }

        // Continue probing
        index = mod_i32(index + 1, cap)
        if (index == start) {
          return Err(())
        }
      }
      Err(_) => { return Err(()) }
    }
  }

  return Err(())
}

/// Free the hash-map.
pub fn hashmap_free(map: HashMap) -> unit {
  map.entries.free()
  return ()
}

/// Demo: insert some values and look them up.
fn run_demo(c: Console, alloc: buffer::Alloc) -> unit {
  c.println("=== Hash-Map Demo (with Hash trait and Vec<Entry>) ===")
  c.println("")
  c.println("This demonstrates a hash-map using:")
  c.println("  - The Hash trait for polymorphic hashing")
  c.println("  - Vec<Entry> for storing custom structs")
  c.println("  - Automatic rehashing when load factor is high")
  c.println("  - Proper tombstone tracking")
  c.println("")

  // Create a hash-map with capacity 16
  let map = hashmap_new(alloc, 16)

  c.println("Inserting entries...")

  // Insert some key-value pairs
  let test_keys = alloc.vec_i32_new()
  let test_vals = alloc.vec_i32_new()

  // key -> key * 10
  match (test_keys.push(42)) { Ok(_) => {} Err(_) => {} }
  match (test_vals.push(420)) { Ok(_) => {} Err(_) => {} }

  match (test_keys.push(17)) { Ok(_) => {} Err(_) => {} }
  match (test_vals.push(170)) { Ok(_) => {} Err(_) => {} }

  match (test_keys.push(99)) { Ok(_) => {} Err(_) => {} }
  match (test_vals.push(990)) { Ok(_) => {} Err(_) => {} }

  match (test_keys.push(1)) { Ok(_) => {} Err(_) => {} }
  match (test_vals.push(10)) { Ok(_) => {} Err(_) => {} }

  match (test_keys.push(256)) { Ok(_) => {} Err(_) => {} }
  match (test_vals.push(2560)) { Ok(_) => {} Err(_) => {} }

  // Keys that will likely collide
  match (test_keys.push(0)) { Ok(_) => {} Err(_) => {} }
  match (test_vals.push(0)) { Ok(_) => {} Err(_) => {} }

  match (test_keys.push(16)) { Ok(_) => {} Err(_) => {} }
  match (test_vals.push(160)) { Ok(_) => {} Err(_) => {} }

  match (test_keys.push(32)) { Ok(_) => {} Err(_) => {} }
  match (test_vals.push(320)) { Ok(_) => {} Err(_) => {} }

  // Insert all entries
  let num_entries = test_keys.len()
  for i in 0..num_entries {
    let k = test_keys[i].unwrap_or(0)
    let v = test_vals[i].unwrap_or(0)
    match (hashmap_insert(map, k, v)) {
      Ok(new_map) => {
        map = new_map
        c.print("  insert(")
        c.print_i32(k)
        c.print(", ")
        c.print_i32(v)
        c.println(") = Ok")
      }
      Err(_) => {
        c.print("  insert(")
        c.print_i32(k)
        c.println(") = Err (failed)")
      }
    }
  }

  c.println("")
  c.print("Map size: ")
  c.print_i32(map.size())
  c.print(", capacity: ")
  c.print_i32(map.capacity())
  c.println("")

  c.println("")
  c.println("Looking up entries...")

  // Look up each key
  for i in 0..num_entries {
    let k = test_keys[i].unwrap_or(0)
    c.print("  get(")
    c.print_i32(k)
    c.print(") = ")
    match (map.get(k)) {
      Ok(v) => {
        c.print_i32(v)
        c.println("")
      }
      Err(_) => {
        c.println("not found")
      }
    }
  }

  c.println("")
  c.println("Updating an entry...")
  c.println("  insert(42, 999) - updating existing key")
  match (hashmap_insert(map, 42, 999)) {
    Ok(new_map) => { map = new_map }
    Err(_) => {}
  }
  c.print("  get(42) = ")
  match (map.get(42)) {
    Ok(v) => {
      c.print_i32(v)
      c.println("")
    }
    Err(_) => {
      c.println("not found")
    }
  }

  c.println("")
  c.println("Looking up non-existent keys...")

  let missing = alloc.vec_i32_new()
  match (missing.push(100)) { Ok(_) => {} Err(_) => {} }
  match (missing.push(999)) { Ok(_) => {} Err(_) => {} }
  match (missing.push(12345)) { Ok(_) => {} Err(_) => {} }

  let num_missing = missing.len()
  for i in 0..num_missing {
    let k = missing[i].unwrap_or(0)
    c.print("  contains(")
    c.print_i32(k)
    c.print(") = ")
    if (map.contains(k)) {
      c.println("true")
    } else {
      c.println("false")
    }
  }

  c.println("")
  c.println("Removing entries...")
  c.print("  remove(17) = ")
  match (hashmap_remove(map, 17)) {
    Ok(new_map) => {
      map = new_map
      c.println("Ok")
    }
    Err(_) => {
      c.println("Err")
    }
  }
  c.print("  contains(17) = ")
  if (map.contains(17)) {
    c.println("true")
  } else {
    c.println("false")
  }
  c.print("Map size: ")
  c.print_i32(map.size())
  c.print(", deleted: ")
  c.print_i32(map.deleted)
  c.println("")

  // Test rehashing by doing many insert/delete cycles
  c.println("")
  c.println("Testing rehash (insert/delete cycles)...")
  for i in 0..20 {
    let k = 1000 + i
    match (hashmap_insert(map, k, k * 10)) {
      Ok(new_map) => { map = new_map }
      Err(_) => {}
    }
  }
  c.print("After 20 inserts - size: ")
  c.print_i32(map.size())
  c.print(", capacity: ")
  c.print_i32(map.capacity())
  c.println("")

  for i in 0..15 {
    let k = 1000 + i
    match (hashmap_remove(map, k)) {
      Ok(new_map) => { map = new_map }
      Err(_) => {}
    }
  }
  c.print("After 15 deletes - size: ")
  c.print_i32(map.size())
  c.print(", deleted: ")
  c.print_i32(map.deleted)
  c.println("")

  // Insert more to trigger tombstone cleanup rehash
  for i in 0..10 {
    let k = 2000 + i
    match (hashmap_insert(map, k, k * 10)) {
      Ok(new_map) => { map = new_map }
      Err(_) => {}
    }
  }
  c.print("After 10 more inserts - size: ")
  c.print_i32(map.size())
  c.print(", deleted: ")
  c.print_i32(map.deleted)
  c.print(", capacity: ")
  c.print_i32(map.capacity())
  c.println("")

  // Cleanup
  alloc.vec_i32_free(test_keys)
  alloc.vec_i32_free(test_vals)
  alloc.vec_i32_free(missing)
  hashmap_free(map)

  c.println("")
  c.println("=== Demo Complete ===")
  return ()
}

pub fn main(rc: RootCap) -> i32 {
  let c = rc.mint_console()
  let alloc = rc.mint_alloc_default()

  run_demo(c, alloc)

  return 0
}
