package safe
module config_loader
use sys::system
use sys::console
use sys::fs
use sys::string
use sys::vec
use sys::buffer

fn print_kv(c: Console, alloc: Alloc, key: string, val: string) -> unit {
  let out = alloc.text_new()
  match (out.push_str("key: ")) {
    Ok(_) => { }
    Err(_) => { out.free(alloc); return () }
  }
  match (out.push_str(key)) {
    Ok(_) => { }
    Err(_) => { out.free(alloc); return () }
  }
  match (out.push_str("\nvalue: ")) {
    Ok(_) => { }
    Err(_) => { out.free(alloc); return () }
  }
  match (out.push_str(val)) {
    Ok(_) => { }
    Err(_) => { out.free(alloc); return () }
  }
  match (out.push_byte('\n')) {
    Ok(_) => { }
    Err(_) => { out.free(alloc); return () }
  }
  c.print(out.as_string())
  out.free(alloc)
  return ()
}

fn parse_line(c: Console, alloc: Alloc, line: string) -> Result<unit, vec::VecErr> {
  if (line.len() == 0) {
    return Ok(())
  }
  if (line.starts_with("#")) {
    return Ok(())
  }

  match (line.index_of_byte('=')) {
    Ok(eq) => {
      let key_result = line.slice_range(0, eq)
      match (key_result) {
        Ok(key) => {
          let val_result = line.slice_range(eq + 1, line.len())
          match (val_result) {
            Ok(val) => { print_kv(c, alloc, key, val) }
            Err(_) => { return Err(vec::VecErr::OutOfRange) }
          }
        }
        Err(_) => { return Err(vec::VecErr::OutOfRange) }
      }
    }
    Err(_) => { }
  }
  return Ok(())
}

fn parse_config(c: Console, alloc: Alloc, contents: string) -> Result<unit, vec::VecErr> {
  let lines = contents.lines(alloc)
  let n = lines.len()
  for i in 0..n {
    let line = lines[i]?
    parse_line(c, alloc, line)?
  }
  alloc.vec_string_free(lines)
  return Ok(())
}

fn run(c: Console, alloc: Alloc, fs: ReadFS) -> Result<unit, FsErr> {
  let contents = fs.read_to_string(alloc, "app.conf")?
  let result = parse_config(c, alloc, contents)
  if (result.is_err()) {
    return Err(fs::FsErr::IoError)
  }
  return Ok(())
}

pub fn main(rc: RootCap) -> i32 {
  let c = rc.mint_console()
  let fs = rc.mint_readfs("examples/config_loader")
  let alloc = rc.mint_alloc_default()
  let result = run(c, alloc, fs)
  if (result.is_ok()) {
    c.println("config ok")
    return 0
  }
  c.println("config read failed")
  return 1
}
