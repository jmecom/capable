package safe
module config_loader
use sys::system
use sys::console
use sys::fs
use sys::string
use sys::vec
use sys::buffer

fn print_kv(c: Console, key: string, val: string) -> unit {
  c.print("key: ")
  c.println(key)
  c.print("value: ")
  c.println(val)
}

fn parse_line(c: Console, alloc: Alloc, line: string) -> Result<unit, VecErr> {
  if (line.len() == 0) {
    return Ok(())
  }
  if (line.starts_with("#")) {
    return Ok(())
  }

  let parts = line.split(61u8)
  if (parts.len() == 2) {
    let key = parts[0]?
    let val = parts[1]?
    print_kv(c, key, val)
  }
  alloc.vec_string_free(parts)
  return Ok(())
}

fn parse_config(c: Console, alloc: Alloc, contents: string) -> Result<unit, VecErr> {
  let lines = contents.lines()
  let n = lines.len()
  for i in 0..n {
    let line = lines[i]?
    parse_line(c, alloc, line)?
  }
  alloc.vec_string_free(lines)
  return Ok(())
}

fn run(c: Console, alloc: Alloc, fs: ReadFS) -> Result<unit, FsErr> {
  let contents = fs.read_to_string("app.conf")?
  let result = parse_config(c, alloc, contents)
  if (result.is_err()) {
    return Err(fs::FsErr::IoError)
  }
  return Ok(())
}

pub fn main(rc: RootCap) -> i32 {
  let c = rc.mint_console()
  let fs = rc.mint_readfs("examples/config_loader")
  let alloc = rc.mint_alloc_default()
  let result = run(c, alloc, fs)
  if (result.is_ok()) {
    c.println("config ok")
    return 0
  }
  c.println("config read failed")
  return 1
}
